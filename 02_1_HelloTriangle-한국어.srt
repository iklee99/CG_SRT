1
00:00:00,000 --> 00:00:04,540
이 노트에서는 2D Triangle 하나를 그리는 과정에 대해 알아보겠습니다.

2
00:00:04,540 --> 00:00:08,700
VBO는 vertex data, 즉, attributes 가 저장되는

3
00:00:08,700 --> 00:00:11,210
GPU 내의 memory를 말합니다.

4
00:00:11,210 --> 00:00:13,700
여기서 vertex attributes는

5
00:00:13,700 --> 00:00:16,770
vertex 좌표, vertex color,

6
00:00:16,770 --> 00:00:21,310
texture coordinates, normal vector 등을 들 수 있는데요.

7
00:00:21,310 --> 00:00:27,140
vertex 좌표나 color는 무엇인지 이미 우리가 알고 있습니다.

8
00:00:27,140 --> 00:00:30,940
나머지 것들에 대해서는 차차 배워 나갈 것입니다.

9
00:00:30,940 --> 00:00:34,270
CPU내의 vertex data는 batch 방식으로

10
00:00:34,270 --> 00:00:38,330
덩어리 채로 VBO로 옮겨지게 되는데,

11
00:00:38,330 --> 00:00:41,510
이것이 immediate mode와 구별되는

12
00:00:41,510 --> 00:00:44,420
core profile 방식의 특징입니다.

13
00:00:44,420 --> 00:00:46,940
여기서 한가지 특이한 것은,

14
00:00:46,940 --> 00:00:48,850
VBO에 data를 저장하는 데에는

15
00:00:48,850 --> 00:00:52,700
미리 고정된 특별한 형식이 없다는 것입니다.

16
00:00:52,700 --> 00:00:55,830
즉, 개발자가 임의로 저장되는 형식을

17
00:00:55,830 --> 00:00:58,980
자유롭게 정할 수 있다는 것입니다.

18
00:00:58,980 --> 00:01:05,280
OpenGL은 3D 공간 중 어떤 부분을 그려 낼 수 있을까요?

19
00:01:05,280 --> 00:01:08,720
그림에서 보듯이 x, y, z 좌표가 모두

20
00:01:08,720 --> 00:01:12,060
-1에서 1 사이인 공간 안에 있을 때

21
00:01:12,060 --> 00:01:14,840
window에 그려질 수 있습니다.

22
00:01:14,840 --> 00:01:17,280
이러한 좌표계를 NDC,

23
00:01:17,280 --> 00:01:22,500
즉, Normalized Device Coordinates라고 합니다.

24
00:01:22,500 --> 00:01:24,620
뒤에서 우리는 camera 배치와

25
00:01:24,620 --> 00:01:28,580
각종 transformation들에 대해 배우게 됩니다만,

26
00:01:28,580 --> 00:01:34,480
당분간 기본적으로 주어진 default camera 만을 사용한다고 가정하면,

27
00:01:34,480 --> 00:01:39,370
이 NDC 공간안에 들어있는 좌표를 가지는 vertex만을

28
00:01:39,370 --> 00:01:43,560
OpenGL이 그려낼 수 있다고 할 수 있습니다.

29
00:01:43,560 --> 00:01:48,030
즉, 당분간 우리는 x, y, z 좌표 모두

30
00:01:48,030 --> 00:01:52,030
-1에서 1 사이에 있는 것들만을 사용하여

31
00:01:52,030 --> 00:01:56,870
여러가지 예제 프로그램을 만들어 볼 것입니다.

32
00:01:56,870 --> 00:01:58,790
Homogeneous coordinates는

33
00:01:58,790 --> 00:02:03,840
N차원 position을 (N+1)차원 vector로 표시합니다.

34
00:02:03,840 --> 00:02:08,600
즉, 3D position은 4D vector로 표시하는 것이죠.

35
00:02:08,600 --> 00:02:14,930
Homogeneous 4D vector [x', y', z', w] 를

36
00:02:14,930 --> 00:02:17,450
3D coordinates 로 바꾸려면

37
00:02:17,450 --> 00:02:25,440
마지막 w 값으로 x', y', z' 값을 나누어 주면 됩니다.

38
00:02:25,440 --> 00:02:30,980
그러므로 4D homogeneous coordinates [x, y, z, 1]은

39
00:02:30,980 --> 00:02:35,420
3D coordinates [x, y, z] 와 같게 됩니다.

40
00:02:35,420 --> 00:02:38,380
여기서 w = 1 이죠.

41
00:02:38,380 --> 00:02:44,110
예를 들어 3D coordinates p 가 [1, 2, 3] 이라고 하면

42
00:02:44,110 --> 00:02:51,120
4D homogeneous로 바꾸면 마지막에 w = 1을 추가하여

43
00:02:51,120 --> 00:02:55,790
p' = [1, 2, 3, 1] 이 됩니다.

44
00:02:55,790 --> 00:03:01,970
반대로 4D homogeneous coordinates p' 을 [2, 4, 6, 2] 이라고 하면

45
00:03:01,970 --> 00:03:09,300
3D coordinates로 바꾸면 x, y, z component들을 w = 2로 나누어서

46
00:03:09,300 --> 00:03:15,840
p = [1, 2, 3] 이 되는 것입니다.

47
00:03:15,840 --> 00:03:18,910
또, 위의 두 예가 의미하는 바는

48
00:03:18,910 --> 00:03:21,670
두 개의 4D homogeneous coordinates

49
00:03:21,670 --> 00:03:27,550
[1, 2, 3, 1] 과 [2, 4, 6, 2] 가 같다는 것입니다.

50
00:03:27,550 --> 00:03:30,750
4차원 homogenous coordinates를 사용하는 이유는

51
00:03:30,750 --> 00:03:33,600
여러 측면에서 이야기 할 수 있습니다.

52
00:03:33,600 --> 00:03:36,130
그러나 가장 직관적인 이유는

53
00:03:36,130 --> 00:03:40,480
translation등의 모든 가능한 transformation operation을

54
00:03:40,480 --> 00:03:44,770
4 x 4 matrix 연산으로 표현하기 위해서 입니다.

55
00:03:44,770 --> 00:03:51,140
이에 관해서는 나중에 transformation 파트에서 배우게 될 것입니다.

56
00:03:51,140 --> 00:03:54,990
여기에서는 Program 02_HelloTriangle을 통해

57
00:03:54,990 --> 00:04:00,230
기본적인 OpenGL drawing에 대해 알아보도록 합니다.

58
00:04:00,230 --> 00:04:04,290
이제 삼각형을 그리는 프로그램을 들여다 볼 시간입니다.

59
00:04:04,290 --> 00:04:06,780
삼각형의 세개의 vertex들의 좌표를

60
00:04:06,780 --> 00:04:10,970
vertices라는 float array에 정의하였습니다.

61
00:04:10,970 --> 00:04:13,580
2D 삼각형을 그릴 것이기 때문에

62
00:04:13,580 --> 00:04:17,590
z 좌표는 모두 0으로 통일하였습니다.

63
00:04:17,590 --> 00:04:20,470
나머지 x와 y 좌표들도

64
00:04:20,470 --> 00:04:25,520
모두 NDC 공간 안의 좌표로 정의된 것을 볼 수 있습니다.

65
00:04:25,520 --> 00:04:29,170
삼각형을 그릴 하나의 VBO의 id를 보관할

66
00:04:29,170 --> 00:04:33,540
변수 VBO를 먼저 선언하였습니다.

67
00:04:33,540 --> 00:04:38,920
그리고 나서 glGenBuffers()로 buffer 한 개를 generate하고

68
00:04:38,920 --> 00:04:42,940
id를 VBO에 리턴 받습니다.

69
00:04:42,940 --> 00:04:47,220
GL_ARRAY_BUFFER에 data를 copy하기 위해

70
00:04:47,220 --> 00:04:52,710
먼저 glBindBuffer()로 현재 VBO를 bind합니다.

71
00:04:52,710 --> 00:04:55,430
마지막으로 glBufferData()로

72
00:04:55,430 --> 00:05:01,510
vertices array의 data를 VBO로 copy합니다.

73
00:05:01,510 --> 00:05:10,150
size는 vertices array의 현재 size를 sizeof 함수로 알아 냅니다.

74
00:05:10,150 --> 00:05:12,440
무언가를 그리기를 원한다면

75
00:05:12,440 --> 00:05:16,790
적어도 아주 간단한 shader가 반드시 존재해야 합니다.

76
00:05:16,790 --> 00:05:22,820
Shader는 OpenGL program으로부터 그려질 대상을 넘겨 받아서

77
00:05:22,820 --> 00:05:27,300
GPU에 명령을 내려주는 독립적인 프로그램입니다.

78
00:05:27,300 --> 00:05:31,470
Shader에 대해서는 이따가 조금 더 자세히 설명하기로 하고,

79
00:05:31,470 --> 00:05:35,850
여기서는 아주 간단한 vertex shader를 소개합니다.

80
00:05:35,850 --> 00:05:38,980
Vertex shader program의 최상단에는

81
00:05:38,980 --> 00:05:44,060
OpenGL Shading Language (GLSL) 의 버전을 씁니다.

82
00:05:44,060 --> 00:05:48,330
여기서는 version 3.3을 사용하고 있습니다.

83
00:05:48,330 --> 00:05:52,230
GLSL의 문법은 C 언어와 비슷합니다.

84
00:05:52,230 --> 00:05:56,850
우리의 첫번째 vertex shader는 OpenGL 프로그램으로부터

85
00:05:56,850 --> 00:05:58,880
단 하나의 vertex attribute,

86
00:05:58,880 --> 00:06:04,000
즉, vertex position coordinates만을 전달 받습니다.

87
00:06:04,000 --> 00:06:06,880
앞에서 VBO에 저장되는 attribute가

88
00:06:06,880 --> 00:06:12,000
vertex coordinates였던 것을 기억하면 됩니다.

89
00:06:12,000 --> 00:06:15,200
aPos는 vertex shader 안에 정의되는 "in" variable 입니다.

90
00:06:15,200 --> 00:06:19,970
즉, OpenGL program으로부터

91
00:06:19,970 --> 00:06:24,870
vertex shader로 유입되는 값이라는 뜻입니다.

92
00:06:24,870 --> 00:06:28,870
layout (location = 0)는

93
00:06:28,870 --> 00:06:32,960
variable이 존재하는 위치 즉 address 값입니다.

94
00:06:32,960 --> 00:06:36,710
여기서는 location이 0입니다.

95
00:06:36,710 --> 00:06:40,570
aPos variable의 type은 vec3 인데

96
00:06:40,570 --> 00:06:46,050
3D vector로 x, y, z 값을 한꺼번에 저장하고 있습니다.

97
00:06:46,050 --> 00:06:48,200
이제 void main() 으로 시작되는

98
00:06:48,200 --> 00:06:52,720
vertex shader program의 body 부분인데요.

99
00:06:52,720 --> 00:06:55,040
gl_Position이라는 predefined variable은

100
00:06:55,040 --> 00:06:59,040
input된 aPos의 x, y, z 값에

101
00:06:59,040 --> 00:07:03,940
w = 1.0 값을 하나 추가해서

102
00:07:03,940 --> 00:07:09,260
4D homogeneous coordinates값을 assign 받게 됩니다.

103
00:07:09,260 --> 00:07:10,910
이 gl_Position은

104
00:07:10,910 --> 00:07:15,500
vertex하나가 실제로 가져야 할 position을 나타내는 값이고

105
00:07:15,500 --> 00:07:19,920
GPU내에서 앞으로의 연산에 이용됩니다.

106
00:07:19,920 --> 00:07:23,730
앞에서 소개한 간단한 vertex shader program의 source code를

107
00:07:23,730 --> 00:07:26,960
하나의 긴 string으로 만들었습니다.

108
00:07:26,960 --> 00:07:32,160
glCreateShader함수로 vertex shader object를 생성합니다.

109
00:07:32,160 --> 00:07:36,660
glShaderSource함수로 소스코드를 assign 합니다.

110
00:07:36,660 --> 00:07:42,260
glCompileShader 함수로 vertex shader를 compile 합니다.

111
00:07:42,260 --> 00:07:45,120
아랫부분은 shader가 컴파일되는 과정에

112
00:07:45,120 --> 00:07:49,870
error가 발생했는지 여부를 check하여 처리하는 부분입니다.

113
00:07:49,870 --> 00:07:53,390
Fragment shader는 Vertex shader와 함께

114
00:07:53,390 --> 00:07:55,860
rendering을 위해 반드시 존재해야 하는

115
00:07:55,860 --> 00:07:59,090
두 개의 shader 중 하나입니다.

116
00:07:59,090 --> 00:08:03,430
Fragment shader는 최종적으로 화면에 보여야 할

117
00:08:03,430 --> 00:08:08,450
pixel 출력의 컬러를 계산하는 역할을 합니다.

118
00:08:08,450 --> 00:08:12,500
Color는 RGBA format으로 나타내지는데요.

119
00:08:12,500 --> 00:08:17,460
Red, Green, Blue, Alpha의 네개의 component들은

120
00:08:17,460 --> 00:08:21,450
각각 0에서 1사이의 값으로 표현됩니다.

121
00:08:21,450 --> 00:08:24,450
Alpha는 투명도를 나타내는 값으로써

122
00:08:24,450 --> 00:08:29,800
0은 완전한 투명, 1은 완전한 불투명 값을 나타냅니다.

123
00:08:29,800 --> 00:08:33,880
FragColor는 "out" 변수로써

124
00:08:33,880 --> 00:08:38,880
최종적인 pixel의 color ouput을 display 하드웨어로 전달합니다.

125
00:08:38,880 --> 00:08:45,540
여기에서는 RGBA 값이 (1.0, 0.5, 0.2, 1.0) 인 단일한 color를

126
00:08:45,540 --> 00:08:48,540
FragColor에 assign했습니다.

127
00:08:48,540 --> 00:08:52,660
앞에서 프로그램 실행의 still image에서 보았던

128
00:08:52,660 --> 00:08:56,960
삼각형의 오렌지색 color가 바로 이것입니다.

129
00:08:56,960 --> 00:08:59,480
OpenGL application program과

130
00:08:59,480 --> 00:09:03,370
vertex shader, fragment shader간의 관계를

131
00:09:03,370 --> 00:09:05,800
이 그림으로 볼 수 있습니다.

132
00:09:05,800 --> 00:09:09,710
Vertex attribute는 application program에서

133
00:09:09,710 --> 00:09:12,020
vertex shader로 전달되어

134
00:09:12,020 --> 00:09:16,900
gl_Position이라는 vertex의 최종 coordinates가 계산된 후

135
00:09:16,900 --> 00:09:19,900
graphics hardware로 전달됩니다.

136
00:09:19,900 --> 00:09:22,940
다른 한쪽에서는 Fragment shader에서

137
00:09:22,940 --> 00:09:26,870
pixel의 color가 결정되어 hardware로 전달됩니다.

138
00:09:26,870 --> 00:09:31,270
사실 application program이나 vertex shader에서

139
00:09:31,270 --> 00:09:34,450
color의 결정을 위해 fragment shader로

140
00:09:34,450 --> 00:09:38,280
어떤 정보를 전달하는 과정이 필요하지만,

141
00:09:38,280 --> 00:09:46,040
이 프로그램에는 아직 그런 전달은 일어나고 있지 않습니다.

142
00:09:46,040 --> 00:09:49,980
이 코드 부분은 OpenGL 응용 프로그램 내에서

143
00:09:49,980 --> 00:09:53,300
fragment shader의 source code를 string으로 나타낸 후

144
00:09:53,300 --> 00:09:56,280
이를 compile하는 과정을 보여주고 있습니다.

145
00:09:56,280 --> 00:10:01,310
기본적인 내용은 vertex shader를 compile하는 부분과 동일하기 때문에

146
00:10:01,310 --> 00:10:05,820
간단히 넘어가도록 하겠습니다.

147
00:10:05,820 --> 00:10:09,930
이제 컴파일된 vertex와 fragment shader로

148
00:10:09,930 --> 00:10:12,390
shader program object를 만들고

149
00:10:12,390 --> 00:10:15,120
이를 linking하는 과정입니다.

150
00:10:15,120 --> 00:10:20,680
Shader program object는 glCreateProgram() 함수로 만들어 집니다.

151
00:10:20,680 --> 00:10:24,410
생성된 shader program object에

152
00:10:24,410 --> 00:10:27,900
vertex와 fragment shader object가 attatch되는데

153
00:10:27,900 --> 00:10:31,990
이를 해 주는 것이 glAttachShader() 함수 입니다.

154
00:10:31,990 --> 00:10:36,590
Attach 이후에는 shader program object를 link해 주는데

155
00:10:36,590 --> 00:10:40,360
glLinkProgram() 함수를 이용합니다.

156
00:10:40,360 --> 00:10:42,700
Linking error를 체크하고 처리하는 부분은

157
00:10:42,700 --> 00:10:46,280
compile 할 때의 경우와 비슷합니다.

158
00:10:46,280 --> 00:10:49,450
vertex와 fragment shader object들은

159
00:10:49,450 --> 00:10:52,510
shader program object가 만들어 진 이후에는

160
00:10:52,510 --> 00:10:56,880
더 이상 필요하지 않기 때문에 delete할 수 있습니다.

161
00:10:56,880 --> 00:11:00,900
Shader program을 OpenGL application program에서

162
00:11:00,900 --> 00:11:03,340
사용하는 것은 간단합니다.

163
00:11:03,340 --> 00:11:09,510
glUseProgram() 함수로 이용할 shader program object를

164
00:11:09,510 --> 00:11:12,200
지정해 주기만 하면 됩니다.

165
00:11:12,200 --> 00:11:17,130
이후에 모든 drawing은 shader program이 담당하게 됩니다.

166
00:11:17,130 --> 00:11:18,990
Shader를 여러 개 만들어 놓고

167
00:11:18,990 --> 00:11:21,680
상황에 따라 다른 shader를 선택하여

168
00:11:21,680 --> 00:11:25,710
렌더링에 사용하는 것도 가능합니다.

169
00:11:25,710 --> 00:11:29,080
이제 VBO에 담긴 vertex attribute들을

170
00:11:29,080 --> 00:11:34,060
vertex shader로 전달하는 과정을 살펴보겠습니다.

171
00:11:34,060 --> 00:11:38,920
우리가 만든 VBO는 이 그림과 같은 format으로 되어 있습니다.

172
00:11:38,920 --> 00:11:41,490
세 개의 vertex들의 3D 좌표들이

173
00:11:41,490 --> 00:11:44,170
차례로 buffer에 들어가게 되는데,

174
00:11:44,170 --> 00:11:48,670
각 차원의 coordinate는 float type 이므로

175
00:11:48,670 --> 00:11:54,350
32bit 즉 4 bytes를 차지하게 됩니다.

176
00:11:54,350 --> 00:11:57,420
따라서 세 개의 vertex들을 위해서는

177
00:11:57,420 --> 00:12:03,440
3 x 3 x 4 = 36 bytes가 필요합니다.

178
00:12:03,440 --> 00:12:07,010
그리고, vertex들의 좌표 간에는 빈 칸, 또는

179
00:12:07,010 --> 00:12:10,100
다른 종류의 data가 없습니다.

180
00:12:10,100 --> 00:12:13,690
즉, 하나의 vertex의 좌표가 끝나면

181
00:12:13,690 --> 00:12:18,880
바로 다음 vertex의 좌표가 이어지는 그런 형태입니다.

182
00:12:18,880 --> 00:12:24,910
전체적으로 보면 모든 data의 시작 부분은 buffer의 시작부분이라서

183
00:12:24,910 --> 00:12:28,590
offset 값은 0 으로 주어집니다.

184
00:12:28,590 --> 00:12:34,350
Stride는 각 vertex의 attribute data가 차지하고 있는 byte의 수인데,

185
00:12:34,350 --> 00:12:44,080
여기에서는 위에서 계산했던 바와 같이 3 x 4 = 12가 됩니다.

186
00:12:44,080 --> 00:12:48,400
OpenGL application에서 만들어진 VBO의 구조를

187
00:12:48,400 --> 00:12:50,830
vertex shader에 알려주어서

188
00:12:50,830 --> 00:12:54,730
vertex shader가 올바르게 vertex attribute 데이터를

189
00:12:54,730 --> 00:12:57,850
읽어 갈 수 있도록 해 주어야 합니다.

190
00:12:57,850 --> 00:13:03,790
이 일을 해주는 function이 glVertexAttribPointer() 입니다.

191
00:13:03,790 --> 00:13:09,040
이 예에서 location은 vertex shader 내의 variable location을 말하며,

192
00:13:09,040 --> 00:13:11,440
값은 0 입니다.

193
00:13:11,440 --> 00:13:15,260
Component의 갯수는 xyz 이므로 3 입니다.

194
00:13:15,260 --> 00:13:19,440
type은 GL_FLOAT 입니다.

195
00:13:19,440 --> 00:13:25,520
attribute값들이 [0, 1] 범위로 사이로 normalized 되어 있으면

196
00:13:25,520 --> 00:13:29,570
normalized parameter가 true, 아니면 false인데,

197
00:13:29,570 --> 00:13:34,690
이 경우에는 vertex coordinates 값에 특별한 계산을 하지 않았으므로

198
00:13:34,690 --> 00:13:38,220
GL_FALSE 로 둡니다.

199
00:13:38,220 --> 00:13:44,140
stride는 한 vertex 부분의 attribute가 차지하는 byte의 수 이므로

200
00:13:44,140 --> 00:13:50,690
3 * sizeof(float), 아까 계산한 대로, 12 였죠.

201
00:13:50,690 --> 00:13:56,010
offset은 첫 data가 buffer의 시작에서 부터 채워지므로,

202
00:13:56,010 --> 00:13:59,340
0 으로 주어집니다.

203
00:13:59,340 --> 00:14:02,820
glEnableVertexAttribArray() 는

204
00:14:02,820 --> 00:14:07,460
glVertexAttribPointer()로 알려준 정보를 토대로

205
00:14:07,460 --> 00:14:13,590
vertex shader내의 location = 0 변수를 활성화 합니다.

206
00:14:13,590 --> 00:14:17,210
이처럼 glVertexAttribPointer와

207
00:14:17,210 --> 00:14:21,510
glEnableVertexAttribArray 함수는

208
00:14:21,510 --> 00:14:25,100
쌍을 이루어서 같이 쓰여집니다.

209
00:14:25,100 --> 00:14:29,060
VAO는 여러개의 VBO들을

210
00:14:29,060 --> 00:14:32,010
한꺼번에 포함하고 있는 object로서,

211
00:14:32,010 --> 00:14:35,970
Vertex Array Object의 약자 입니다.

212
00:14:35,970 --> 00:14:38,830
하나의 물체가 여러개의 VBO들의 조합으로

213
00:14:38,830 --> 00:14:41,470
나타내지는 경우가 많은 경우,

214
00:14:41,470 --> 00:14:46,970
이들을 일일히 bind하고, 렌더링하는 것이 복잡해질 수 있습니다.

215
00:14:46,970 --> 00:14:51,780
이 과정을 간단히 해 주는 것이 VAO 입니다.

216
00:14:51,780 --> 00:14:59,400
그림에서 첫번째 object는 position attribute를 VBO1에 저장하였고,

217
00:14:59,400 --> 00:15:03,760
color attribute는 VBO2에 저장하였습니다.

218
00:15:03,760 --> 00:15:09,950
우리는 이 두개의 VBO들을 VAO1 하나로 묶을 수 있고,

219
00:15:09,950 --> 00:15:12,850
VAO1 만을 bind함으로써

220
00:15:12,850 --> 00:15:16,800
쉽게 렌더링 상태를 지정할 수 있게 됩니다.

221
00:15:16,800 --> 00:15:19,470
반면에 아랫쪽의 두 번째 object는

222
00:15:19,470 --> 00:15:24,410
하나의 VBO3 안에 position과 color attribute들을

223
00:15:24,410 --> 00:15:26,760
모두 저장하였습니다.

224
00:15:26,760 --> 00:15:36,000
이 경우에도 VAO2가 VBO3를 포함하도록 할 수 있습니다.

225
00:15:36,000 --> 00:15:42,110
VAO를 생성하기 위해 glGenVertexArray() 함수를 사용합니다.

226
00:15:42,110 --> 00:15:46,720
VAO에 속하게 될 VBO들도 생성합니다.

227
00:15:46,720 --> 00:15:51,020
glBindVertexArray를 call하여 VAO를 bind합니다.

228
00:15:51,020 --> 00:15:57,080
이후에는 정상적인 VBO operation을 행하는데,

229
00:15:57,080 --> 00:16:00,870
VBO를 bind하고, data를 copy하고,

230
00:16:00,870 --> 00:16:05,120
attributes를 vertex shader로 전달합니다.

231
00:16:05,120 --> 00:16:10,900
이렇게 하나의 VAO가 bind된 상태에서 생성되는 VBO들은

232
00:16:10,900 --> 00:16:16,410
현재 bind된  VAO에 자동적으로 속하게 되겠습니다.

233
00:16:16,410 --> 00:16:23,200
이제 VBO가 VAO에 속한 상태에서 적절한 VAO를 선택하면

234
00:16:23,200 --> 00:16:27,510
어떤 것을 그릴 것인지를 쉽게 지정할 수 있습니다.

235
00:16:27,510 --> 00:16:32,350
Rendering loop에서 그릴 VAO와 shader를 지정하고

236
00:16:32,350 --> 00:16:38,370
glDrawArrays() 를 이용하여 primitive를 렌더링 합니다.

237
00:16:38,370 --> 00:16:43,120
glDrawArrays의 parameter는 primitive를 지정하는데,

238
00:16:43,120 --> 00:16:47,960
여기에서는 GL_TRIANGLES로 지정하였습니다.

239
00:16:47,960 --> 00:16:52,590
그 뒤의 parameter들로는 VAO의 starting index와

240
00:16:52,590 --> 00:16:58,690
vertex의 숫자를 지정합니다.

241
00:16:58,690 --> 00:17:02,550
GL_TRIANGLES와 같이 OpenGL이 그려낼 수 있는

242
00:17:02,550 --> 00:17:05,290
primitive들은 여러가지가 있습니다.

243
00:17:05,290 --> 00:17:12,470
그림에서 vertex의 번호들은 VBO에 저장된 vertex의 순서를 나타냅니다.

244
00:17:12,470 --> 00:17:16,830
GL_POINTS는 point들 하나 하나를 그려내는 것이고,

245
00:17:16,830 --> 00:17:23,080
GL_LINES는 연이은 두 개의 vertex들을 쌍을 이루어서

246
00:17:23,080 --> 00:17:27,400
그들을 잇는 line segment들을 그려냅니다.

247
00:17:27,400 --> 00:17:32,190
GL_LINE_LOOP 는 마지막 vertex와 첫 vertex를 이어주는

248
00:17:32,190 --> 00:17:35,800
loop를 렌더링하게 됩니다.

249
00:17:35,800 --> 00:17:38,430
GL_LINE_STRIP은 연이어 주어지는 vertex들을

250
00:17:38,430 --> 00:17:42,640
차례로 연결하는 line들을 그립니다.

251
00:17:42,640 --> 00:17:45,700
GL_TRIANGLES는 주어진 vertex들을

252
00:17:45,700 --> 00:17:50,700
세개씩 묶어 삼각형을 그리게 됩니다.

253
00:17:50,700 --> 00:17:53,380
GL_TRIANGLE_STRIP은 처음 주어진

254
00:17:53,380 --> 00:17:56,760
세개의 vertex로 삼각형을 하나 정의하고,

255
00:17:56,760 --> 00:18:00,610
이후 주어지는 vertex들이 하나씩 추가 될 때마다

256
00:18:00,610 --> 00:18:04,620
새로운 삼각형을 만들게 합니다.

257
00:18:04,620 --> 00:18:09,340
GL_TRIANGLE_FAN도 비슷한 형태입니다만

258
00:18:09,340 --> 00:18:12,360
첫번째 입력된 vertex 1번을 중심으로

259
00:18:12,360 --> 00:18:14,860
삼각형이 만들어 진다는 것이

260
00:18:14,860 --> 00:18:18,830
GL_TRIANGLE_STRIP과 다른 점입니다.

261
00:18:18,830 --> 00:18:27,020
그 외에 사각형이나 다른 다각형들을 위해 정의된 primitive들은 없습니다.

262
00:18:27,020 --> 00:18:33,250
이 그림은 graphics pipeline의 세부 stage들을 나타내고 있습니다.

263
00:18:33,250 --> 00:18:37,960
GPU로 전달된 vertex data는 vertex shader,

264
00:18:37,960 --> 00:18:43,570
shape assembly, geometry shader, rasterization,

265
00:18:43,570 --> 00:18:47,460
fragment shader, tests and blending 이라는

266
00:18:47,460 --> 00:18:52,460
세부 단계를 거쳐 화면 상에 보이게 됩니다.

267
00:18:52,460 --> 00:18:58,390
세부 단계들 중 파란색으로 칠해 진 부분은 shader들로서

268
00:18:58,390 --> 00:19:01,200
프로그램이 가능한 부분들 입니다.

269
00:19:01,200 --> 00:19:05,170
회색 단계들은 GPU에서 제공하는 기능들인데,

270
00:19:05,170 --> 00:19:07,650
흔히 hardware로 제작되어 있어서,

271
00:19:07,650 --> 00:19:11,370
매우 빠른 processing을 가능하게 합니다.

272
00:19:11,370 --> 00:19:17,010
이번 코스에서 우리는 vertex shader와 fragment shader에 대해서만

273
00:19:17,010 --> 00:19:19,270
공부를 할 것입니다.
