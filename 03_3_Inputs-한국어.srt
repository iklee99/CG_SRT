1
00:00:00,000 --> 00:00:04,450
여기서는 GLFW가 처리해 주는 keyboard, mouse 등의

2
00:00:04,450 --> 00:00:07,420
입력 처리에 관한 내용을 살펴봅니다.

3
00:00:07,420 --> 00:00:09,940
GLFW의 input 처리에 대한 guide는

4
00:00:09,940 --> 00:00:13,110
document page에서 볼 수 있습니다.

5
00:00:13,110 --> 00:00:15,800
GLFW에서 input에 대한 처리를 하는

6
00:00:15,800 --> 00:00:17,680
두 가지 방법이 있습니다.

7
00:00:17,680 --> 00:00:20,200
하나는 callback function을 등록해 놓고,

8
00:00:20,200 --> 00:00:23,000
해당하는 input이 들어왔을 때 callback function이

9
00:00:23,000 --> 00:00:26,270
자동으로 실행되게 하는 것입니다.

10
00:00:26,270 --> 00:00:31,850
다른 하나는 glfwGet으로 시작하는 함수들을 사용하여,

11
00:00:31,850 --> 00:00:35,810
그 순간의 입력 상태를 읽어오는 방법입니다.

12
00:00:35,810 --> 00:00:38,060
이 중에서 더 안정적인 방식은

13
00:00:38,060 --> 00:00:40,540
callback 을 이용하는 것입니다만,

14
00:00:40,540 --> 00:00:42,490
어떤 경우에는 glfwGet...

15
00:00:42,490 --> 00:00:44,360
을 이용하는 편이

16
00:00:44,360 --> 00:00:46,540
더 편할 수 있습니다.

17
00:00:46,540 --> 00:00:47,520
예를 들면,

18
00:00:47,520 --> 00:00:50,600
현재의 mouse position을 return 해 주는

19
00:00:50,600 --> 00:00:58,170
glfwGetCursorPos 등이 그렇습니다.

20
00:00:58,170 --> 00:01:00,310
glfwSetKeyCallback은 callback 함수를

21
00:01:00,310 --> 00:01:02,000
지정하는 function입니다.

22
00:01:02,000 --> 00:01:06,740
key_callback에 적절한 callback 함수이름을 넣으면 됩니다.

23
00:01:06,740 --> 00:01:08,290
Callback함수가 call되면,

24
00:01:08,290 --> 00:01:13,030
action이 일어난 key를 나타내는 macro, 즉, constant와,

25
00:01:13,030 --> 00:01:16,720
action이 parameter로 함께 주어집니다.

26
00:01:16,720 --> 00:01:20,960
key macro는 여기 주어진 GLFW의 document page에

27
00:01:20,960 --> 00:01:24,480
잘 나와 있으니 참고 하기 바랍니다.

28
00:01:24,480 --> 00:01:30,380
action은 세개가 있는데 GLFW_PRESS는 key가 눌려진 즉시,

29
00:01:30,380 --> 00:01:36,520
GLFW_REPEAT는 key를 계속 누르고 있을때 발생하며,

30
00:01:36,520 --> 00:01:45,310
GLFW_RELEASE는 눌려진 key가 놓아지는 순간 발생합니다.

31
00:01:45,310 --> 00:01:47,650
glfwGetKey는 keyboard input이 발생했는지를

32
00:01:47,650 --> 00:01:50,750
application program이 직접 check합니다.

33
00:01:50,750 --> 00:01:54,610
key parameter는 program이 check하고 싶은 key를 나타내며,

34
00:01:54,610 --> 00:02:03,620
return 값은 integer로서 GLFW_PRESS 또는 GLFW_RELEASE 입니다.

35
00:02:03,620 --> 00:02:07,170
GLFW_REPEAT는 return값에 포함되지 않습니다.

36
00:02:07,170 --> 00:02:12,630
이 예제 프로그램에서는 'f' key가 Press 되었는지를 check하여

37
00:02:12,630 --> 00:02:16,640
뭔가를 하게 합니다.

38
00:02:16,640 --> 00:02:19,070
glfwSetCursorPosCallback은

39
00:02:19,070 --> 00:02:21,190
mouse cursor의 position이 변할 때,

40
00:02:21,190 --> 00:02:26,000
즉 mouse가 움직이고 있을때 계속 반복되는 call입니다.

41
00:02:26,000 --> 00:02:30,100
(xpos, ypos) 를 double 값의 pair로 return 하는데,

42
00:02:30,100 --> 00:02:33,370
screen coordinates로 표시한 것입니다.

43
00:02:33,370 --> 00:02:37,600
screen coordinates는 그림에서 보듯 왼쪽 상단이 (0,0)

44
00:02:37,600 --> 00:02:43,490
오른쪽 하단은 display의 resolution 만큼되는 공간입니다.

45
00:02:43,490 --> 00:02:46,950
한가지 기억해야 할 것은 이 event는 mouse button이

46
00:02:46,950 --> 00:02:52,420
눌렸는지 아닌지 여부에 상관없이 계속 발생한다는 것입니다.

47
00:02:52,420 --> 00:02:57,090
또, (xpos, ypos) 는 mouse cursor가 drawing window안에

48
00:02:57,090 --> 00:03:01,310
있는지의 여부에 상관없이 return 됩니다.

49
00:03:01,310 --> 00:03:05,860
한편, glfwGetCursorPos 함수를 call 하면

50
00:03:05,860 --> 00:03:10,570
현재 mouse cursor의 위치를 return 해 줍니다.

51
00:03:10,570 --> 00:03:14,930
Cursor가 윈도우에 들어가고 나올때 발생하는 event가 있습니다.

52
00:03:14,930 --> 00:03:20,230
이러한 event를 window focus/unfocus 라고 합니다.

53
00:03:20,230 --> 00:03:23,890
Callback에서 entered는 boolean variable로서

54
00:03:23,890 --> 00:03:27,320
true이면 cursor가 window에 들어갈 때 발생한 것이고,

55
00:03:27,320 --> 00:03:32,470
false이면 나올때 발생한 것입니다.

56
00:03:32,470 --> 00:03:34,700
glfwSetMouseButtonCallback은

57
00:03:34,700 --> 00:03:39,140
Mouse의 button이 눌렸거나 풀렸을 때 발생합니다.

58
00:03:39,140 --> 00:03:43,140
Timer 함수로는 glfwGetTime()이 있는데,

59
00:03:43,140 --> 00:03:47,920
glfw가 처음 initialize 되고 난 이후 지나간 시간을

60
00:03:47,920 --> 00:03:50,730
초단위로 return 합니다.

61
00:03:50,730 --> 00:03:52,040
double값을 return 하기 때문에

62
00:03:52,040 --> 00:03:56,810
정밀한 시간값을 얻을 수 있습니다.

63
00:03:56,810 --> 00:03:59,770
glfwSetTime을 사용하면 자신이 원하는 시간으로

64
00:03:59,770 --> 00:04:02,770
timer를 맞출 수 있습니다.

65
00:04:02,770 --> 00:04:08,240
이제 Keyboard input을 이용하여 삼각형을 위아래로 뒤집거나 (f key),

66
00:04:08,240 --> 00:04:13,600
색깔을 바꾸는 (r,g,b key) 프로그램을 보도록 하겠습니다.

67
00:04:13,600 --> 00:04:16,730
Vertex shader에서는 이전처럼 aPos를

68
00:04:16,730 --> 00:04:20,990
vertex의 position attribute로 전달받고,

69
00:04:20,990 --> 00:04:25,250
multY 라는 uniform variable을 하나 더 전달 받습니다.

70
00:04:25,250 --> 00:04:28,640
multY는 1 또는 -1 인데,

71
00:04:28,640 --> 00:04:31,780
vertex의 y좌표에 곱해져서,

72
00:04:31,780 --> 00:04:35,810
-1일 때는 삼각형이 위아래로 뒤집히게 됩니다.

73
00:04:35,810 --> 00:04:39,410
Fragment shader는 이전의 것과 같습니다.

74
00:04:39,410 --> 00:04:44,190
outColor는 vertex shader로 부터 전달 받지는 않고,

75
00:04:44,190 --> 00:04:49,310
application program으로 부터 직접 uniform으로 전달 받게 됩니다.

76
00:04:49,310 --> 00:04:51,040
Application program의 global variable들로

77
00:04:51,040 --> 00:04:55,490
bool type의 verticalFlip 이 있고,

78
00:04:55,490 --> 00:05:00,860
삼각형의 color를 나타내는 colorR, colorG, colorB 가 있습니다.

79
00:05:00,860 --> 00:05:05,770
Keyboard callback 함수인 key_callback을 register하였습니다.

80
00:05:05,770 --> 00:05:08,640
key_callback 에서 f key가 press되면

81
00:05:08,640 --> 00:05:12,260
verticalFlip을 true와 false로 toggle합니다.

82
00:05:12,260 --> 00:05:16,040
r key가 눌리면 colorR = 1.0으로 하고

83
00:05:16,040 --> 00:05:19,410
나머지 colorG, colorB는 0으로 합니다.

84
00:05:19,410 --> 00:05:26,240
마찬가지로 g와 b key가 눌릴때도 color를 적절히 바꾸어 줍니다.

85
00:05:26,240 --> 00:05:29,020
main loop에서 삼각형을 렌더링하기 전에

86
00:05:29,020 --> 00:05:30,970
verticalFlip을 검사하여

87
00:05:30,970 --> 00:05:36,090
true이면 multY uniform 변수를 -1 값으로 전달합니다.

88
00:05:36,090 --> 00:05:39,550
만약 false라면 그냥 1을 전달합니다.

89
00:05:39,550 --> 00:05:41,200
또, Fragment shader로는

90
00:05:41,200 --> 00:05:46,490
삼각형의 color를 직접 uniform 변수 outColor로 전달합니다.

91
00:05:46,490 --> 00:05:50,570
outColor가 RGBA를 나타내는 4D vector이기 때문에

92
00:05:50,570 --> 00:05:57,780
colorR, colorG, colorB에 1.0을 함께 전달합니다.

93
00:05:57,780 --> 00:05:59,470
Program 09_Polyline은

94
00:05:59,470 --> 00:06:03,210
mouse의 왼쪽 버튼을 눌러 점을 하나씩 입력합니다.

95
00:06:03,210 --> 00:06:07,790
입력된 점들 사이를 연결하는 line segment들이 보여지며,

96
00:06:07,790 --> 00:06:10,490
새로 입력될 후보 점의 위치에 따라

97
00:06:10,490 --> 00:06:13,090
마지막 선분이 계속 변하면서,

98
00:06:13,090 --> 00:06:17,450
입력될 선분에 대한 예측을 가능하게 해 줍니다.

99
00:06:17,450 --> 00:06:22,460
점을 입력한 후 left mouse button을 계속 누르고 있을 필요가 없습니다.

100
00:06:22,460 --> 00:06:27,380
'r' key를 누르면 입력된 모든 점들이 사라지면서 reset이 됩니다.

101
00:06:27,380 --> 00:06:30,150
입력된 점들의 color가 계속 변하면서,

102
00:06:30,150 --> 00:06:32,990
점들을 잇는 line segment의 color는

103
00:06:32,990 --> 00:06:36,820
끝점들의 color를 interpolate하고 있습니다.

104
00:06:36,820 --> 00:06:39,840
Global 변수들을 살펴보겠습니다.

105
00:06:39,840 --> 00:06:44,460
입력 가능 vertex의 수는 MAX_VERTEX = 200 입니다.

106
00:06:44,460 --> 00:06:48,710
Position attribute를 3D 좌표로 나타내려고 하므로

107
00:06:48,710 --> 00:06:54,260
vertex position attribute data의 size인

108
00:06:54,260 --> 00:06:57,950
MAX_VERTEX_SIZE는 MAX_VERTEX * 3 입니다.

109
00:06:57,950 --> 00:07:01,060
Color attribute를 RGBA로 나타내므로

110
00:07:01,060 --> 00:07:03,650
color attribute data의 size는

111
00:07:03,650 --> 00:07:06,050
MAX_COLOR_SIZE = MAX_VERTEX * 4 입니다.

112
00:07:06,050 --> 00:07:14,190
nPoint는 현재 입력된 point의 갯수를 저장하게 됩니다.

113
00:07:14,190 --> 00:07:16,890
초기 값은 0 입니다.

114
00:07:16,890 --> 00:07:20,540
stopInput은 right mouse button 눌렀을 때 true가 되어

115
00:07:20,540 --> 00:07:25,190
더 이상의 input을 받지 못하게 하는 역할을 합니다.

116
00:07:25,190 --> 00:07:28,580
nextPoint는 mouse cursor moving 시작 때

117
00:07:28,580 --> 00:07:32,510
한 point가 더 입력되게 하는 역할을 합니다.

118
00:07:32,510 --> 00:07:37,250
VBO[0]는 position, VBO[1]은 color를 위한

119
00:07:37,250 --> 00:07:39,580
두 개의 buffer object 입니다.

120
00:07:39,580 --> 00:07:43,620
vertices는 현재까지 입력된 vertex들을 담고 있는

121
00:07:43,620 --> 00:07:45,900
position data를 저장합니다.

122
00:07:45,900 --> 00:07:51,140
colors는 각 입력 vertex의 color를 가지고 있게 됩니다.

123
00:07:51,140 --> 00:07:53,540
colorOriginal은 6개의 기본 color로

124
00:07:53,540 --> 00:08:00,060
point들은 들어오는 순서대로 color를 하나씩 배정받게 됩니다.

125
00:08:00,060 --> 00:08:04,690
Callback 으로는 key 'r' 을 받는 Keyboard input callback이 필요합니다.

126
00:08:04,690 --> 00:08:09,150
Mouse 움직임을 잡는 CursorPosCallback과

127
00:08:09,150 --> 00:08:10,680
Mouse left button과

128
00:08:10,680 --> 00:08:15,490
right button을 받는 MouseButtonCallback도 지정하였습니다.

129
00:08:15,490 --> 00:08:20,830
프로그램에 필요한 VAO와 VBO를 정의한 부분에 대해 보겠습니다.

130
00:08:20,830 --> 00:08:27,260
하나의 VAO안에 두개의 VBO (VBO[0], VBO[1]) 가 존재합니다.

131
00:08:27,260 --> 00:08:32,960
VBO[0]는 position attribute로 3D coordinates를 가지고 있습니다.

132
00:08:32,960 --> 00:08:39,900
VBO[1]은 color attribute로 RGBA (4D) 를 가지고 있습니다.

133
00:08:39,900 --> 00:08:44,320
VBO[0]는 attribute id = 0와 연결됩니다.

134
00:08:44,320 --> 00:08:49,090
VBO[1]은 attribute id = 1과 연결됩니다.

135
00:08:49,090 --> 00:08:52,920
key ‘r’이 들어오면 nPoints = 0으로 하고

136
00:08:52,920 --> 00:08:55,900
stopInput, nextInput을 모두 초기화합니다.

137
00:08:55,900 --> 00:08:59,890
즉, input이 전혀 없었던 초기 상태로 만듭니다.

138
00:08:59,890 --> 00:09:02,580
left mouse button 이 눌려진 경우,

139
00:09:02,580 --> 00:09:06,500
stopInput이 true 이면 더 이상 input을 받지 않으므로

140
00:09:06,500 --> 00:09:11,030
false일 때만 point 입력을 받습니다.

141
00:09:11,030 --> 00:09:14,180
glfwGetCursorPos로 현재 mouse position

142
00:09:14,180 --> 00:09:16,800
(xpos, ypos)를 구하고

143
00:09:16,800 --> 00:09:20,890
이를 [-1,1] 구간의 좌표로

144
00:09:20,890 --> 00:09:25,680
normalize (normalize_cursor_position) 합니다.

145
00:09:25,680 --> 00:09:28,760
그리고 position attribute

146
00:09:28,760 --> 00:09:30,840
VBO[0]의 position을 update합니다.

147
00:09:30,840 --> 00:09:35,750
특별히 nPoints=0 일 때는 nPoints를 1로 해 주어야

148
00:09:35,750 --> 00:09:38,910
다음의 다른 state들과 같은 상태가 됩니다.

149
00:09:38,910 --> 00:09:43,570
이제 right mouse button press인 경우를 봅니다.

150
00:09:43,570 --> 00:09:47,390
역시 stopInput이 false인 경우에만

151
00:09:47,390 --> 00:09:49,410
마지막 point를 추가 합니다.

152
00:09:49,410 --> 00:09:52,110
그리고 stopInput = true로 만듭니다.

153
00:09:52,110 --> 00:09:54,710
screen 좌표의 y좌표는 (위에서 아래로)

154
00:09:54,710 --> 00:10:00,910
0으로 부터 SCR_HEIGHT까지 증가하고,

155
00:10:00,910 --> 00:10:04,710
x는 0에서 SCR_WIDTH까지 (좌에서 우로) 증가 합니다.

156
00:10:04,710 --> 00:10:11,710
이것을 OpenGL의 NDC (-1,-1) ~ (1,1)로 바꾸려 합니다.

157
00:10:11,710 --> 00:10:17,010
먼저 screen coordinates의 x 좌표를

158
00:10:17,010 --> 00:10:21,300
[0,1] 사이로 normalize하고 (x/SCR_WIDTH),

159
00:10:21,300 --> 00:10:25,300
이를 두 배 하고, 1을 빼 주면,

160
00:10:25,300 --> 00:10:27,150
[-1,1] 사이로 변환됩니다.

161
00:10:27,150 --> 00:10:29,860
y 좌표의 경우, 비슷한 과정을 따르면서,

162
00:10:29,860 --> 00:10:35,760
위 아래를 바꾸기 위해 -1을 마지막으로 곱해 줍니다.

163
00:10:35,760 --> 00:10:40,160
update_vb_vertex 함수는 새로운 vertex가 입력되었을 때,

164
00:10:40,160 --> 00:10:44,830
기존의 VBO에서 vIndex에 해당하는 부분을 update합니다.

165
00:10:44,830 --> 00:10:50,810
glBufferSubData는 VBO의 일부분만을 update하는 기능을 합니다.

166
00:10:50,810 --> 00:10:53,990
glBufferSubData의 offset (시작점)을

167
00:10:53,990 --> 00:10:57,570
vIndex * sizeof(float) * 3 으로 합니다.

168
00:10:57,570 --> 00:11:02,210
즉, 현재 VBO의 data의 마지막 data가 끝나는 position을

169
00:11:02,210 --> 00:11:06,690
offset으로 하여 한 point만을 추가 해 줄 것입니다.

170
00:11:06,690 --> 00:11:10,910
그리고 추가될 data의 크기는 sizeof(float) * 3 이 됩니다.

171
00:11:10,910 --> 00:11:13,540
마지막으로 추가될 new data는

172
00:11:13,540 --> 00:11:16,900
n[3] array로 추가된 point 입니다.

173
00:11:16,900 --> 00:11:20,850
렌더링 파트에서는 VBO 중에서 nPoints 갯수만큼만의

174
00:11:20,850 --> 00:11:23,140
GL_LINE_STRIP을 그리게 하면

175
00:11:23,140 --> 00:11:28,270
현재까지 입력된 line strip만을 그리게 할 수 있습니다.
