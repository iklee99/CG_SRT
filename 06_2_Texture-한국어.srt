1
00:00:00,000 --> 00:00:04,310
Texture mapping 강의 시작하겠습니다.

2
00:00:04,310 --> 00:00:06,530
CG 장면을 그려내는데 있어

3
00:00:06,530 --> 00:00:09,690
현실감을 단계적으로 표현해 보도록 합시다.

4
00:00:09,690 --> 00:00:14,000
첫번 그림에는 출연하는 물체들의 geometry

5
00:00:14,000 --> 00:00:19,420
즉 모양만을 사용하여서,  그리 현실적이지 않습니다.

6
00:00:19,420 --> 00:00:22,750
다음 것은 Phong shading을 사용한 것인데,

7
00:00:22,750 --> 00:00:25,080
여전히 뭔가 부족합니다.

8
00:00:25,080 --> 00:00:28,160
마지막 것은 shading과 texture map을

9
00:00:28,160 --> 00:00:34,380
같이 사용한 것인데, 훨씬 현실적으로 보입니다.

10
00:00:34,380 --> 00:00:36,650
Texture mapping은 CG 장면에

11
00:00:36,650 --> 00:00:40,190
현실감을 주는 디테일을 추가해 줍니다.

12
00:00:40,190 --> 00:00:45,700
상세한 2D 이미지로 object를 감싸듯 렌더링하는 것입니다.

13
00:00:45,700 --> 00:00:50,900
이 디테일을 만약 모두 모델링으로만 구현하려면

14
00:00:50,900 --> 00:00:55,500
매우 많이 vertex와 face가 필요할 것이어서

15
00:00:55,500 --> 00:00:58,530
많이 어렵고 복잡할 것입니다.

16
00:00:58,530 --> 00:01:02,870
Texture mapping은 훨씬 효율적인 방법을 제공합니다.

17
00:01:02,870 --> 00:01:07,870
Texture mapping은 1974년 미국 Utah 대학을 졸업한

18
00:01:07,870 --> 00:01:13,250
Edwin Catmull의 박사논문에 포함되어 발표되었습니다.

19
00:01:13,250 --> 00:01:18,110
그는 유명한 애니메이션 제작사인 Pixar의 공동 창업자이며,

20
00:01:18,110 --> 00:01:22,930
Walt Disney Animation Studio의 CEO 를 맡고 있습니다.

21
00:01:22,930 --> 00:01:28,320
그는 2019년에 ACM Turing Award를 수상했습니다.

22
00:01:28,320 --> 00:01:30,300
그는 texture-mapping 이외에도

23
00:01:30,300 --> 00:01:34,690
bicubic surface, spatial anti-aliasing,

24
00:01:34,690 --> 00:01:38,760
subdiviision surface, z-buffering 등

25
00:01:38,760 --> 00:01:40,790
현재 CG에 꼭 필요한

26
00:01:40,790 --> 00:01:45,450
중요한 기술들을 많이 발명한 선구자 입니다.

27
00:01:45,450 --> 00:01:47,530
Texture mapping 기술은 그 후

28
00:01:47,530 --> 00:01:53,990
Catmull의 후배인 Blinn과 Newell 등에 의해 더 발전되었습니다.

29
00:01:53,990 --> 00:01:59,090
Texture coordinates라는 용어를 먼저 설명하겠습니다.

30
00:01:59,090 --> 00:02:01,510
이 좌표는 texture image 위의

31
00:02:01,510 --> 00:02:04,370
위치를 지정하기 위해 사용하는 것입니다.

32
00:02:04,370 --> 00:02:08,380
일반적으로 (u,v) 또는 (s,t) 로 표시합니다.

33
00:02:08,380 --> 00:02:12,500
또 가로 세로 축 모두 0부터 1사이의 값을 가지도록

34
00:02:12,500 --> 00:02:14,690
되어 있습니다.

35
00:02:14,690 --> 00:02:20,060
Texture coordinates가 하는 역할을 알아보도록 하겠습니다.

36
00:02:20,060 --> 00:02:25,020
여기에 전자회로기판 모양의 texture image가 있습니다.

37
00:02:25,020 --> 00:02:30,750
이 texture image에는 texture coordinates가 지정되어 있습니다.

38
00:02:30,750 --> 00:02:32,800
Texture mapping의 source가 될

39
00:02:32,800 --> 00:02:36,990
간단한 모양의 mesh가 있다고 가정해 봅시다.

40
00:02:36,990 --> 00:02:41,980
이 mesh의 모양은 직사각형이 아니라 약간 찌그러져 있습니다.

41
00:02:41,980 --> 00:02:46,840
이제 네개의 vertex에 texture coordinates를 주어서

42
00:02:46,840 --> 00:02:51,540
texture image가 mesh에 mapping되도록 해 보겠습니다.

43
00:02:51,540 --> 00:02:54,980
먼저 첫번째 방법에서는 네개의 vertex에

44
00:02:54,980 --> 00:03:02,450
texture coordinates (0,0), (1,0), (1,1), (0,1)을 주었습니다.

45
00:03:02,450 --> 00:03:08,420
이렇게 되면 texture image의 전체 영역이 mesh로 mapping됩니다.

46
00:03:08,420 --> 00:03:13,030
Mesh가 찌그려져 있기 때문에 image도 같이 찌그러져서

47
00:03:13,030 --> 00:03:16,620
원래 texture와는 좀 달라 보입니다.

48
00:03:16,620 --> 00:03:20,670
두번째 방법에서는 texture image의 일부만을 사용하도록

49
00:03:20,670 --> 00:03:24,160
texture coordinates를 좀 바꿔 보았습니다.

50
00:03:24,160 --> 00:03:32,890
즉, (1,0)과 (1,1) 대신에 (0.9, 0.4)와 (1, 0.7)을 주었습니다.

51
00:03:32,890 --> 00:03:36,200
texture image 전체가 mapping되지는 않았지만,

52
00:03:36,200 --> 00:03:40,610
찌그러짐이 방지되는 것을 확인할 수 있습니다.

53
00:03:40,610 --> 00:03:43,160
Texture coordinates는 이와 같이

54
00:03:43,160 --> 00:03:47,390
object에 texture image 어느 부분이 mapping되어야 하는지를

55
00:03:47,390 --> 00:03:50,720
지정하는데 사용할 수 있습니다.

56
00:03:50,720 --> 00:03:53,250
texture coordinates는 일반적으로

57
00:03:53,250 --> 00:03:57,190
(0,0) 부터 (1,1)까지의 범위를 가집니다.

58
00:03:57,190 --> 00:04:02,940
만일 이 range를 넘는 texture coordinates가 있다면 어떤 일이 벌어질까요?

59
00:04:02,940 --> 00:04:08,350
OpenGL의 default는 GL_REPEAT 옵션으로 이런 경우를 처리합니다.

60
00:04:08,350 --> 00:04:13,600
즉, 같은 texture image를 계속해서 반복하는 것입니다.

61
00:04:13,600 --> 00:04:16,860
그림의 가장 왼쪽의 경우입니다.

62
00:04:16,860 --> 00:04:20,670
GL_MIRRORED_REPEAT는 반복을 하되

63
00:04:20,670 --> 00:04:23,300
경계선에서 방향을 바꾸어

64
00:04:23,300 --> 00:04:26,550
거울에 반사 되듯이 하는 것입니다.

65
00:04:26,550 --> 00:04:29,990
GL_CLAMP_TO_EDGE는 texture image의

66
00:04:29,990 --> 00:04:35,380
경계에 있는 픽셀만을 계속 반복해 나갑니다.

67
00:04:35,380 --> 00:04:39,340
GL_CLAMP_TO_BORDER는 border color로 정한

68
00:04:39,340 --> 00:04:42,710
특정 color를 반복합니다.

69
00:04:42,710 --> 00:04:44,900
그림의 가장 오른쪽의 경우,

70
00:04:44,900 --> 00:04:49,920
짙은 녹색 border color가 사용된 경우를 보여줍니다.

71
00:04:49,920 --> 00:04:54,960
많은 경우에 texture coordinates의 두 축 방향은

72
00:04:54,960 --> 00:04:57,620
s와 t로 표기합니다.

73
00:04:57,620 --> 00:05:02,160
s는 가로 축, t는 세로 축을 나타냅니다.

74
00:05:02,160 --> 00:05:07,290
Texture를 wrapping하는 방식은 glTexParameteri 함수의

75
00:05:07,290 --> 00:05:12,210
GL_TEXTURE_WRAP_S 또는 GL_TEXTURE_WRAP_T 를

76
00:05:12,210 --> 00:05:15,000
이용하여 지정합니다.

77
00:05:15,000 --> 00:05:22,040
이 예에서는 S와 T방향 모두 GL_MIRRORED_REPEAT로 지정하였습니다.

78
00:05:22,040 --> 00:05:25,530
glTexParameterfv를 이용하여

79
00:05:25,530 --> 00:05:29,430
texture의 border color를 지정할 수도 있습니다.

80
00:05:29,430 --> 00:05:34,230
glTexParameter 뒤에 붙이는 i 는 integer,

81
00:05:34,230 --> 00:05:38,520
fv는 float vector type을 나타냅니다.

82
00:05:38,520 --> 00:05:42,970
Texture map image와 screen pixel의 크기와 개수의 차이는

83
00:05:42,970 --> 00:05:49,020
근본적으로 texture mapping에서 aliasing 문제를 발생시킵니다.

84
00:05:49,020 --> 00:05:52,410
이 그림에서 check 무늬의 texture map image가

85
00:05:52,410 --> 00:05:57,360
perspective projection 된 사다리꼴에 mapping 되고 있습니다.

86
00:05:57,360 --> 00:06:00,710
texture와 polygon에 대응하는 point들이

87
00:06:00,710 --> 00:06:03,400
그림에 표시되어 있습니다.

88
00:06:03,400 --> 00:06:08,270
사다리꼴이 rasterizing 되고 각 pixel에 해당하는

89
00:06:08,270 --> 00:06:13,680
texture의 color들이 뽑아져 맨 오른쪽과 같이 mapping 됩니다.

90
00:06:13,680 --> 00:06:19,310
그러나 이 결과가 좋은 결과는 결코 아닌 것이 분명합니다.

91
00:06:19,310 --> 00:06:25,730
이를 방지하기 위해 anti-aliasing 기법들이 사용되어야 합니다.

92
00:06:25,730 --> 00:06:29,820
이 그림에서는 왼쪽에 aliasing이 일어나서

93
00:06:29,820 --> 00:06:32,840
texture가 깨지는 경우를 보여주고 있고,

94
00:06:32,840 --> 00:06:36,160
오른쪽은 anti-aliasing 을 사용하여

95
00:06:36,160 --> 00:06:39,700
texture mapping의 결과를 개선한 것입니다.

96
00:06:39,700 --> 00:06:43,850
간단하게는 주위의 texel color들을 평균하여

97
00:06:43,850 --> 00:06:47,710
color를 결정하는 filtering 방법이 있습니다.

98
00:06:47,710 --> 00:06:50,750
texture의 texel을 더 잘게 쪼개는

99
00:06:50,750 --> 00:06:54,170
over sampling 방법도 있습니다.

100
00:06:54,170 --> 00:06:57,720
Filtering 방법에 대해 더 알아보기로 합시다.

101
00:06:57,720 --> 00:07:01,040
Texture와 polygon을 나타내는 pixel들의 크기가

102
00:07:01,040 --> 00:07:03,350
딱 들어맞지 않기 때문에

103
00:07:03,350 --> 00:07:07,990
texture를 확대 또는 축소해야 하는 경우들이 생깁니다.

104
00:07:07,990 --> 00:07:11,930
예를 들어 polygon의 하나의 pixel P가

105
00:07:11,930 --> 00:07:15,180
texture안의 여러개의 texel들로 이루어진

106
00:07:15,180 --> 00:07:21,890
하나의 사각형(quadrilateral)에 mapping될 때는,

107
00:07:21,890 --> 00:07:26,840
texture image를 축소 (minification) 해야 합니다.

108
00:07:26,840 --> 00:07:29,760
반대로 polygon의 여러개의 pixel들이

109
00:07:29,760 --> 00:07:33,740
texture의 단 한개의 texel과 mapping 되는 경우에는

110
00:07:33,740 --> 00:07:39,330
texture image를 확대(magnify) 해야 합니다.

111
00:07:39,330 --> 00:07:42,200
Texture가 입혀질 polygon의 pixel이

112
00:07:42,200 --> 00:07:46,690
texture image의 texel과 딱 들어맞지 않는 경우가 대부분인데,

113
00:07:46,690 --> 00:07:51,630
이 때 polygon pixel에 칠해질 color를 texture image로 부터

114
00:07:51,630 --> 00:07:56,660
계산해 내는 과정을 "texture filtering" 이라 합니다.

115
00:07:56,660 --> 00:08:00,920
"Nearest filter" 는 OpenGL의 default filtering 방법입니다.

116
00:08:00,920 --> 00:08:03,670
Nearest filtering을 사용하는 경우,

117
00:08:03,670 --> 00:08:07,440
그림과 같이 빨강색 polygon pixel이

118
00:08:07,440 --> 00:08:10,340
여러개의 texture texel에 걸쳐 있는 경우,

119
00:08:10,340 --> 00:08:17,490
그 pixel의 중심이 속한 texture의 texel color를 그대로 사용하게 됩니다.

120
00:08:17,490 --> 00:08:21,250
주위의 color를 합하여 평균을 낸다던지 하는

121
00:08:21,250 --> 00:08:24,980
추가 프로세싱이 없는 것입니다.

122
00:08:24,980 --> 00:08:29,100
이 방법은 texture mapping 시간을 단축하는데 도움이 되지만,

123
00:08:29,100 --> 00:08:32,050
전체 polygon에 걸쳐 texture mapping의 질은

124
00:08:32,050 --> 00:08:34,720
그리 좋지 않을 가능성이 있습니다.

125
00:08:34,720 --> 00:08:38,320
왜냐하면 이웃하는 polygon pixel들의 color가

126
00:08:38,320 --> 00:08:42,070
급격하게 바뀔 가능성이 있기 때문입니다.

127
00:08:42,070 --> 00:08:44,340
Default 방법이기 때문에

128
00:08:44,340 --> 00:08:48,060
따로 filtering 방법을 명시할 필요는 없읍니다만,

129
00:08:48,060 --> 00:08:53,500
이와 같이 glTexParameteri 의 GL_TEXTURE_MIN_FILTER

130
00:08:53,500 --> 00:09:01,190
또는 GL_TEXTURE_MAG_FILTER 값을 GL_NEAREST로 지정하면 됩니다.

131
00:09:01,190 --> 00:09:03,050
이번에 소개할 방법은,

132
00:09:03,050 --> 00:09:08,230
지정한 texture coordinates (polygon pixel의 중심) 을

133
00:09:08,230 --> 00:09:12,420
포함하는 texel 주변의 texel color들을 평균하여

134
00:09:12,420 --> 00:09:14,750
interpolation 하는 방법으로,

135
00:09:14,750 --> 00:09:20,070
"linear filter" 또는 "Bilinear filter"라 불립니다.

136
00:09:20,070 --> 00:09:23,720
그림에 보면 빨강색 polygon pixel이

137
00:09:23,720 --> 00:09:26,000
여러개의 texel들에 걸쳐 있고,

138
00:09:26,000 --> 00:09:32,400
결정되는 color는 이들을 적절히 평균한 interpolation된 color입니다.

139
00:09:32,400 --> 00:09:35,080
간단히 이 방법을 설명한다면,

140
00:09:35,080 --> 00:09:37,250
polygon pixel center에서

141
00:09:37,250 --> 00:09:42,180
고려하는 texel center까지의 거리가 가까우면 가까울 수록

142
00:09:42,180 --> 00:09:46,750
그 texel의 color의 비중을 더 높이는 것입니다.

143
00:09:46,750 --> 00:09:50,290
이 방식을 써서 texture filtering을 하려면

144
00:09:50,290 --> 00:09:55,280
GL_TEXTURE_MIN_FILTER 또는 GL_TEXTURE_MAG_FILTER를

145
00:09:55,280 --> 00:09:59,120
GL_LINEAR 방식으로 지정해야 합니다.

146
00:09:59,120 --> 00:10:01,770
Nearest filter와 Linear filter를

147
00:10:01,770 --> 00:10:07,420
각각 사용한 경우의 texture mapping 결과를 비교해 보았습니다.

148
00:10:07,420 --> 00:10:09,980
왼쪽의 nearest filter의 경우에는

149
00:10:09,980 --> 00:10:13,680
screen pixel마다 mapping된 texture texel의 color의

150
00:10:13,680 --> 00:10:15,780
변화가 심해지기 때문에

151
00:10:15,780 --> 00:10:19,290
이웃하는 pixel들의 경계를 알아볼 수 있을 정도로

152
00:10:19,290 --> 00:10:21,650
안 좋은 결과가 나왔습니다.

153
00:10:21,650 --> 00:10:26,600
그러나 각각의 pixel color들은 매우 선명하게 보입니다.

154
00:10:26,600 --> 00:10:28,680
오른쪽의 linear filter의 경우

155
00:10:28,680 --> 00:10:32,400
이웃하는 texel들의 color들을 interpolation하여

156
00:10:32,400 --> 00:10:35,280
pixel의 color를 결정하기 때문에

157
00:10:35,280 --> 00:10:36,970
이웃하는 pixel들의 color는

158
00:10:36,970 --> 00:10:40,440
유연하게 변하는 것을 확인할 수 있습니다.

159
00:10:40,440 --> 00:10:44,180
그러나 전반적으로 texture mapping 이후의 결과는

160
00:10:44,180 --> 00:10:50,520
이미지에 등장하는 object들의 경계선이 뚜렷하지 않은 현상을 보여 줍니다.

161
00:10:50,520 --> 00:10:55,930
두 가지 방법들 간의 trade-off라 볼 수 있습니다.

162
00:10:55,930 --> 00:10:58,910
Mipmap은 크기가 다른 texture image들을

163
00:10:58,910 --> 00:11:03,800
렌더링 전에 미리 준비해 두는 것을 말합니다.

164
00:11:03,800 --> 00:11:07,180
OpenGL은 사용자가 하나의 texture 이미지를 load한 후

165
00:11:07,180 --> 00:11:11,330
mipmap을 만들어 준비해 주는 명령을 가지고 있습니다.

166
00:11:11,330 --> 00:11:16,360
이렇게 하면, screen pixel에서 차지하는 texture image의 크기에 따라

167
00:11:16,360 --> 00:11:20,970
적절한 texture image를 골라서 사용할 수 있게 됩니다.

168
00:11:20,970 --> 00:11:24,540
즉 screen pixel의 크기와 texture texel의 크기를

169
00:11:24,540 --> 00:11:28,920
최대한 비슷하게 유지하자는 겁니다.

170
00:11:28,920 --> 00:11:31,740
Mipmap 방식을 사용한 것과 안 한 것은

171
00:11:31,740 --> 00:11:36,730
최종적인 texture mapping의 품질에 많은 영향을 미칩니다.

172
00:11:36,730 --> 00:11:40,220
그림에서 왼쪽 것은 mipmap을 적용하지 않은 경우,

173
00:11:40,220 --> 00:11:44,330
오른쪽은 적용한 경우를 나타냅니다.

174
00:11:44,330 --> 00:11:48,330
이것은 mipmap을 적용하지 않았을 때와 했을 때의

175
00:11:48,330 --> 00:11:50,530
또다른 비교 결과 입니다.

176
00:11:50,530 --> 00:11:53,740
왼쪽 그림이 mipmap이 없는 경우이고,

177
00:11:53,740 --> 00:11:56,820
오른쪽이 mipmap이 있는 경우입니다.

178
00:11:56,820 --> 00:11:59,590
Mipmap이 없는 경우 screen pixel의

179
00:11:59,590 --> 00:12:03,660
이웃간에 mapping되는 texture color의 차이가 심해져서

180
00:12:03,660 --> 00:12:07,690
깜빡거림 현상이 심하게 나타날 수 있습니다.

181
00:12:07,690 --> 00:12:10,360
OpenGL은 loading된 texture image의

182
00:12:10,360 --> 00:12:14,180
mipmap chain을 만들어 주는 기능을 가지고 있습니다.

183
00:12:14,180 --> 00:12:19,210
거기에 사용되는 함수가 "glGenerateMipmaps" 입니다.

184
00:12:19,210 --> 00:12:23,270
parameter인 target으로는 보통 GL_TEXTURE_2D 가

185
00:12:23,270 --> 00:12:25,650
사용될 수 있습니다.

186
00:12:25,650 --> 00:12:28,090
mipmap chain은 최종 level에서

187
00:12:28,090 --> 00:12:31,860
pixel이 하나만 남을 때까지 계속 됩니다.

188
00:12:31,860 --> 00:12:35,530
level이 높아질 수록 resolution은

189
00:12:35,530 --> 00:12:39,220
width, height 각 1/2 씩 줄어들고,

190
00:12:39,220 --> 00:12:42,830
image의 size, 즉, width, height도

191
00:12:42,830 --> 00:12:48,010
각각 하위 레벨의 1/2 씩 줄어들게 됩니다.

192
00:12:48,010 --> 00:12:52,120
Mipmap이 만들어지고 나면, filtering 방법으로

193
00:12:52,120 --> 00:12:55,660
mipmap 기능이 추가된 option을 사용할 수 있습니다.

194
00:12:55,660 --> 00:13:01,290
먼저, GL_NEAREST_MIPMAP_NEAREST 의 앞쪽 NEAREST는,

195
00:13:01,290 --> 00:13:03,600
이전에 말했듯이, 가장 가까운 texel의

196
00:13:03,600 --> 00:13:07,330
color를 그냥 취하는 방법을 나타냅니다.

197
00:13:07,330 --> 00:13:10,040
뒷쪽의 NEAREST는 여러장의 mipmap 중에

198
00:13:10,040 --> 00:13:13,190
어떤 것을 사용할 것인지를 나타냅니다.

199
00:13:13,190 --> 00:13:19,020
NEAREST이니까 현재 pixel 크기와 가장 크기가 비슷한 texel을 가지는

200
00:13:19,020 --> 00:13:24,020
이미지를 mipmap hierarchy 중에 선택합니다.

201
00:13:24,020 --> 00:13:27,340
GL_LINEAR_MIPMAP_NEAREST는

202
00:13:27,340 --> 00:13:31,770
color를 정할 때에는 LINEAR interpolation 방식을 사용하고,

203
00:13:31,770 --> 00:13:37,720
mipmap을 선택하는 방식은 그냥 nearest로 선택하는 것입니다.

204
00:13:37,720 --> 00:13:40,740
GL_NEAREST_MIPMAP_LINEAR는

205
00:13:40,740 --> 00:13:43,750
color는 NEAREST 방식으로 결정하지만,

206
00:13:43,750 --> 00:13:48,260
screen pixel의 크기와 가장 비슷한 크기의 texel을 가지는

207
00:13:48,260 --> 00:13:51,980
두 장의 mipmap image들 사이를 linear로 보간한

208
00:13:51,980 --> 00:13:57,410
새로운 크기의 texture image를 만들어 사용하는 것입니다.

209
00:13:57,410 --> 00:14:02,760
GL_LINEAR_MIPMAP_LINEAR는 color 결정도 linear 방식으로,

210
00:14:02,760 --> 00:14:08,100
mipmap image 결정도 linear interpolation 방식으로 계산하는 것입니다.

211
00:14:08,100 --> 00:14:12,820
따라서 가장 많은 계산 시간이 걸립니다.

212
00:14:12,820 --> 00:14:16,790
Mipmap을 사용한 texture mapping의 예를 들어 보겠습니다.

213
00:14:16,790 --> 00:14:21,730
Base texture는 8x4 의 resolution을 가집니다.

214
00:14:21,730 --> 00:14:25,380
OpenGL이 base texture로 부터

215
00:14:25,380 --> 00:14:28,710
2x2 개의 texel들을 average해서

216
00:14:28,710 --> 00:14:32,590
이미지를 축소해 나가면서 mipmap을 생성합니다.

217
00:14:32,590 --> 00:14:38,770
예를 들면 아래쪽 4x2 mipmap의 texel '3'은

218
00:14:38,770 --> 00:14:48,260
위쪽 base texture의 2x2 texel들인 (4, 2, 3, 3)을 평균내어 구해졌습니다.

219
00:14:48,260 --> 00:14:53,450
이제 rasterizing 된 삼각형의 한 pixel이

220
00:14:53,450 --> 00:15:00,150
base texture의 2x2 texel들로 mapping 된다고 가정합니다.

221
00:15:00,150 --> 00:15:03,050
즉, 이러한 경우는, texel들에

222
00:15:03,050 --> 00:15:07,110
minification이 적용되어야 하는 경우 입니다.

223
00:15:07,110 --> 00:15:08,710
이 경우, 우리는 base texture의

224
00:15:08,710 --> 00:15:13,860
2x2 texel들을 mapping하는 것이 아니라,

225
00:15:13,860 --> 00:15:18,380
미리 만들어 놓은 4x2 mipmap의 texel

226
00:15:18,380 --> 00:15:21,990
'3'을 fetch해서 사용할 수 있습니다.

227
00:15:21,990 --> 00:15:27,220
이렇게 하면 렌더링 중간에 계산 시간을 단축할 수도 있으며,

228
00:15:27,220 --> 00:15:33,350
mipmap을 만드는 방식에 따라 렌더링의 질도 높일 수 있습니다.

229
00:15:33,350 --> 00:15:38,280
Texture mapping이 적용된 첫 example program 입니다.

230
00:15:38,280 --> 00:15:42,890
Cube의 여섯 면에 모두 같은 texture가 mapping되어 있습니다.

231
00:15:42,890 --> 00:15:46,500
이제 cube.h 안에 정의된 Cube class에서

232
00:15:46,500 --> 00:15:50,760
texture coordinates 부분을 다시 살펴보도록 하겠습니다.

233
00:15:50,760 --> 00:15:54,790
cube는 위의 그림과 같이 index 0 부터 7까지

234
00:15:54,790 --> 00:15:58,240
8개의 vertexe들을 가지고 있습니다.

235
00:15:58,240 --> 00:16:04,920
이 중 front face인 (v0, v1, v2, v3) 사각형을 고려하면

236
00:16:04,920 --> 00:16:09,120
texture coordinates (1,0), (0, 0), (0, 1), (1,1) 들이

237
00:16:09,120 --> 00:16:14,930
각각 v0, v1, v2, v3에 mapping 되었습니다.

238
00:16:14,930 --> 00:16:18,520
그림에서 노랑색 화살표들을 보면 됩니다.

239
00:16:18,520 --> 00:16:24,900
즉, texture 이미지의 좌우와 상하가 반대로 뒤집혀 mapping된 것입니다.

240
00:16:24,900 --> 00:16:27,200
이것은 일반적인 경우는 아니며,

241
00:16:27,200 --> 00:16:32,280
사실 이 예제의 경우 texture map 이미지가 좌우, 상하로 대칭이므로

242
00:16:32,280 --> 00:16:35,340
큰 문제는 없습니다.

243
00:16:35,340 --> 00:16:38,750
그러나 일반적인 경우라면, v0, v1, v2, v3에

244
00:16:38,750 --> 00:16:42,070
(1, 1), (0,1), (0, 0), (1,0) 이

245
00:16:42,070 --> 00:16:45,170
각각 mapping되는 것이 맞습니다.

246
00:16:45,170 --> 00:16:50,580
cube.h의 buffer 초기화 부분에서 VBO에 데이터를 채울 때,

247
00:16:50,580 --> 00:16:52,220
position, normal, color,

248
00:16:52,220 --> 00:16:55,740
texture coordinates 데이터의 총 합의 크기만큼을

249
00:16:55,740 --> 00:16:59,470
먼저 glBufferData로 잡아 놓습니다.

250
00:16:59,470 --> 00:17:03,370
그리고 나서 glBufferSubData를 이용해

251
00:17:03,370 --> 00:17:09,180
offset vSize+nSize+cSize 만큼을 주고,

252
00:17:09,180 --> 00:17:10,960
texture coordinates data를

253
00:17:10,960 --> 00:17:15,540
buffer로 copy하는 방식을 사용했습니다.

254
00:17:15,540 --> 00:17:18,610
cube의 buffer 초기화 맨 끝 부분에,

255
00:17:18,610 --> 00:17:22,810
vertex shader로 data를 전달하는 부분에서는,

256
00:17:22,810 --> 00:17:25,060
texture coordinates 데이터들이

257
00:17:25,060 --> 00:17:31,610
shader의 attribute variable 번호 3번으로 전달되도록 했습니다.

258
00:17:31,610 --> 00:17:35,830
데이터 타입은 2D vector의 array입니다.

259
00:17:35,830 --> 00:17:39,020
vertex shader에서 그 동안 무시되어 왔던

260
00:17:39,020 --> 00:17:42,930
texture coordinates를 이제 사용해야 합니다.

261
00:17:42,930 --> 00:17:44,800
Application program으로부터

262
00:17:44,800 --> 00:17:48,690
location 3번인 변수 "aTexCoord"로

263
00:17:48,690 --> 00:17:54,250
2D vector인 texture coordinates가 전달되었습니다.

264
00:17:54,250 --> 00:17:57,640
이 texture coordinates는 fragment shader로 전달되는데,

265
00:17:57,640 --> 00:18:03,540
out variable인 toTexCoord를 사용합니다.

266
00:18:03,540 --> 00:18:07,750
Fragment shader에서는 vertex shader로 부터 pass된

267
00:18:07,750 --> 00:18:13,980
texture coordinates를 in 변수인 "toTexCoord"로 받습니다.

268
00:18:13,980 --> 00:18:18,100
toTexCoord의 타입과 이름이 vertex shader의 out variable과

269
00:18:18,100 --> 00:18:21,240
같음에 유의해야 합니다.

270
00:18:21,240 --> 00:18:26,270
Texture map을 위한 shader의 변수의 type은 sampler2D 입니다.

271
00:18:26,270 --> 00:18:31,190
"texture" 는 predefined된 shader 함수로써

272
00:18:31,190 --> 00:18:35,510
texture map으로부터 texture coordinates로 주어진

273
00:18:35,510 --> 00:18:37,440
texel의 color를 계산하고,

274
00:18:37,440 --> 00:18:43,350
이 color는 최종 color인 FragColor로 assign됩니다.

275
00:18:43,350 --> 00:18:50,890
Application program 에서는 stb_image.h 라이브러리 함수를

276
00:18:50,890 --> 00:18:55,410
include 하기 위해 위의 두 라인을 이용합니다.

277
00:18:55,410 --> 00:19:03,130
stbi_image는 bmp, jpg, png 등

278
00:19:03,130 --> 00:19:08,570
다양한 포맷의 이미지 파일들을 texture로 읽어 들일 수 있습니다.

279
00:19:08,570 --> 00:19:12,230
loadTexture() 함수에서는 texture mapping을 위한

280
00:19:12,230 --> 00:19:16,430
모든 준비를 하고, texture image를 load합니다.

281
00:19:16,430 --> 00:19:21,970
먼저 texture object를 generate하고 그 id를 받아 옵니다.

282
00:19:21,970 --> 00:19:26,730
VAO, VBO 때와 마찬가지로 여러개의 texture object들을

283
00:19:26,730 --> 00:19:30,580
동시에 generate할 수도 있습니다.

284
00:19:30,580 --> 00:19:33,530
glBindTexture는

285
00:19:33,530 --> 00:19:38,310
이후의 모든 texture관련 operation들이나 rendering에서

286
00:19:38,310 --> 00:19:42,840
이 texture object를 사용하라는 명령입니다.

287
00:19:42,840 --> 00:19:47,500
Texture wrapping에서 사용될 방식을 지정하는 부분에서,

288
00:19:47,500 --> 00:19:50,020
s 방향으로는 GL_CLAMP,

289
00:19:50,020 --> 00:19:54,710
t 방향으로는 GL_REPEAT를 사용하고 있습니다.

290
00:19:54,710 --> 00:19:58,540
사실 이 프로그램에서는 texture coordinates가

291
00:19:58,540 --> 00:20:05,330
가로 세로 방향 모두 [0,1] 구간을 벗어나는 일이 없기 때문에,

292
00:20:05,330 --> 00:20:08,470
wrapping이 사용되지는 않습니다.

293
00:20:08,470 --> 00:20:12,260
이 부분에서는 texture minification과

294
00:20:12,260 --> 00:20:13,900
maginification을 위한

295
00:20:13,900 --> 00:20:16,540
filtering 방법들을 지정하고 있는데,

296
00:20:16,540 --> 00:20:21,490
모두 GL_LINEAR 방식으로 지정하였습니다.

297
00:20:21,490 --> 00:20:25,140
loadTexture의 다음 부분에서는 이미지 파일을

298
00:20:25,140 --> 00:20:31,500
stb_image의 library 함수인 stbi_load로 읽어 들입니다.

299
00:20:31,500 --> 00:20:37,440
파일을 읽는 동안 발생할 수 있는 error 처리도 함께 해 줍니다.

300
00:20:37,440 --> 00:20:43,120
glTexImage2D 함수는 현재 bind되어 있는 texture object에

301
00:20:43,120 --> 00:20:47,160
이미지 데이터를 copy하는 역할을 합니다.

302
00:20:47,160 --> 00:20:49,810
glGenerateMipmap 함수는

303
00:20:49,810 --> 00:20:54,500
texture object의 mipmap을 generate 합니다.
