1
00:00:00,000 --> 00:00:03,720
Indexed Triangle 강의 시작하겠습니다.

2
00:00:03,720 --> 00:00:06,680
이 프로그램에서는 두 개의 삼각형을 이용하여

3
00:00:06,680 --> 00:00:09,530
하나의 사각형을 그려 볼 것입 니다.

4
00:00:09,530 --> 00:00:13,100
이 과정에서 앞의 예제와는 달리 index를 이용하여

5
00:00:13,100 --> 00:00:16,500
vertex data를 지정 하는 방식을 사용합니다.

6
00:00:16,500 --> 00:00:19,520
'r' key를 누르면 삼각형 내부를 칠하거나

7
00:00:19,520 --> 00:00:23,120
edge 만을 보여주거나 하는 방식 사이를

8
00:00:23,120 --> 00:00:26,350
toggle로 선택할 수 있습니다.

9
00:00:26,350 --> 00:00:31,810
두 개의 삼각형들로 하나의 사각형을 그리는 경우를 고려해 봅시다.

10
00:00:31,810 --> 00:00:35,820
삼각형 하나에 세개의 vertex들이 필요하니까

11
00:00:35,820 --> 00:00:40,290
모두 6개의 vertex들의 데이터 가 필요한 것일까요?

12
00:00:40,290 --> 00:00:45,590
vertices array에 이렇게 여섯 개의 vertex 좌표를 배치하고 보니,

13
00:00:45,590 --> 00:00:48,580
bottom right 와 top left 는

14
00:00:48,580 --> 00:00:52,670
두 개의 삼각형들에 공통적으로 포함되어 있습니다.

15
00:00:52,670 --> 00:00:57,630
따라서 실제로는 4개의 vertex들 만이 필요하게 됩니다.

16
00:00:57,630 --> 00:01:02,260
이런 경우, 인덱스들을 이용하는 방법이 있습니다.

17
00:01:02,260 --> 00:01:06,940
즉, vertex data에는 중복된 데이터를 넣지 않고,

18
00:01:06,940 --> 00:01:13,120
삼각형 등의 primitive를 위한 연결 (위상, topology) 정보는

19
00:01:13,120 --> 00:01:17,280
index array로 따로 저장하는 것입니다.

20
00:01:17,280 --> 00:01:22,430
이 예에서는, 4개의 vertex coordinates 만을 이용하고,

21
00:01:22,430 --> 00:01:25,070
두 개의 삼각형을 정의 하는 것을

22
00:01:25,070 --> 00:01:28,590
vertex의 index를 이용하도록 하였습니다.

23
00:01:28,590 --> 00:01:33,850
지금의 예에서는 인덱스를 이용하는 방식의 장점이 두드러져 보이지 않으나,

24
00:01:33,850 --> 00:01:37,910
수 만개의 삼각형들로 복잡한 모델을 만드는 경우에

25
00:01:37,910 --> 00:01:42,120
데이터 양이 줄어드는 효과는 매우 클 수 있을 것입니다.

26
00:01:42,120 --> 00:01:46,560
index를 OpenGL에서 Element라 부릅니다.

27
00:01:46,560 --> 00:01:51,420
VBO와 마찬가지로 index도 buffering을 할 수 있습니다.

28
00:01:51,420 --> 00:01:57,500
이것을 Element Buffer Object (EBO)라고 부릅니다.

29
00:01:57,500 --> 00:02:02,940
EBO 를 generate 하고 id를 얻는 것은 VBO 때와 같이

30
00:02:02,940 --> 00:02:06,720
glGenBuffers() 함수를 이용합니다.

31
00:02:06,720 --> 00:02:10,370
EBO를 bind하고 데이터를 copy할때

32
00:02:10,370 --> 00:02:15,120
target으로 GL_ELEMENT_ARRAY_BUFFER 를 사용합니다.

33
00:02:15,120 --> 00:02:21,040
VBO의 경우 GL_ARRAY_BUFFER 를 target으로 했었죠.

34
00:02:21,040 --> 00:02:25,200
bind하고 copy하는 과정은 VBO와 유사합니다.

35
00:02:25,200 --> 00:02:29,150
한가지 유의할 점은 EBO를 생성한 이후에도

36
00:02:29,150 --> 00:02:32,700
unbind하지 않는 것이 좋다는 것 입니다.

37
00:02:32,700 --> 00:02:41,760
또 한가지, VAO는 VBO와 EBO를 모두 포함할 수 있다는 것입니다.

38
00:02:41,760 --> 00:02:45,970
man loop 안의 drawing operation들을 살펴보시죠.

39
00:02:45,970 --> 00:02:49,110
그런데 glClear() 전에 여태까지 있었던

40
00:02:49,110 --> 00:02:52,570
processInput() 함수가 없어졌습니다.

41
00:02:52,570 --> 00:03:00,700
그러면 ESC와 r key가 눌렸는지를 어떻게 check할 수 있을까요?

42
00:03:00,700 --> 00:03:06,780
이 프로그램에서는 그 기능을 keyboard callback function으로 옮겼습니다.

43
00:03:06,780 --> 00:03:10,660
glPolygonMode() 를 이용해서 polygon을 그릴 때

44
00:03:10,660 --> 00:03:16,290
polygon의 내부를 칠할 것인 지, 바깥쪽 edge만을 그릴 것인지를

45
00:03:16,290 --> 00:03:18,460
지정할 수 있습니다.

46
00:03:18,460 --> 00:03:24,010
일종의 drawing state 를 바꾸는 명령입니다.

47
00:03:24,010 --> 00:03:28,490
fillTriangle은 global variable로서 keyboard callback에서

48
00:03:28,490 --> 00:03:33,500
"r" key가 눌릴 때 마 다 true/false를 번갈아 가지게 됩니다.

49
00:03:33,500 --> 00:03:35,810
true인 경우 내부를 칠하고,

50
00:03:35,810 --> 00:03:41,760
false인 경우 GL_LINE 즉 edge로 그리게 됩니다.

51
00:03:41,760 --> 00:03:44,670
glDrawElements() 는 index를 사용하여

52
00:03:44,670 --> 00:03:48,230
object를 그려내는 function 입니다.

53
00:03:48,230 --> 00:03:51,360
GL_TRIANGLES가 primitive target이고

54
00:03:51,360 --> 00:03:54,880
6개의 index, 즉, 삼각형 두 개가 있으 며,

55
00:03:54,880 --> 00:04:00,860
맨 마지막 parameter인 0는 시작 부분의 offset입니다.

56
00:04:00,860 --> 00:04:03,360
keyboard callback을 사용하기 위해서

57
00:04:03,360 --> 00:04:09,440
callback function을 미리 glfwSetKeyCallback() 함수를 사용하여

58
00:04:09,440 --> 00:04:10,980
등록합니다.

59
00:04:10,980 --> 00:04:15,180
여기서는 key_callback() 이라는 function을

60
00:04:15,180 --> 00:04:18,000
callback function으로 등록 했습니다.

61
00:04:18,000 --> 00:04:20,700
Keyboard callback function의 parameter들 중

62
00:04:20,700 --> 00:04:23,370
key는 어떤 key인지를 나타내 고,

63
00:04:23,370 --> 00:04:29,060
action은 눌려졌는지 (GLFW_PRESS)

64
00:04:29,060 --> 00:04:36,420
눌려져 있다가 풀렸는지 (GLFW_RELEASE) 중 하나를 나타냅니다.

65
00:04:36,420 --> 00:04:40,220
각 action마다 다른 event 처리를 할 수 있습니다.

66
00:04:40,220 --> 00:04:45,690
여기서는 ESC key가 들어오면 window를 close하여 끝나도록 했고,

67
00:04:45,690 --> 00:04:50,820
'r' key가 눌려지면 fillTriangle 이라는 global variable의 값이

68
00:04:50,820 --> 00:04:54,880
true 와 false간을 toggle 되도록 하였습니다.

69
00:04:54,880 --> 00:04:58,130
이제부터는 HelloTriangle을 변형한

70
00:04:58,130 --> 00:05:02,100
세가지 예제들의 program들을 살펴 보도 록 하겠습니다.

71
00:05:02,100 --> 00:05:08,220
먼저 04_HelloTriangleExample1에서는 두 개의 삼각형들을 그리는데,

72
00:05:08,220 --> 00:05:13,960
하나의 VAO와 하나의 VBO를 사용하는 경우 입니다.

73
00:05:13,960 --> 00:05:18,260
이 프로그램은 원래의 02_HelloTriangle 프로그램과

74
00:05:18,260 --> 00:05:20,390
다른 것이 거의 없습니다.

75
00:05:20,390 --> 00:05:24,670
다만 vertices data에 3개가 아닌 6개의 vertex들의

76
00:05:24,670 --> 00:05:28,320
position coordinates 들을 넣었습니다.

77
00:05:28,320 --> 00:05:32,160
VAO와 VBO를 만드는 나머지 과정은 모두

78
00:05:32,160 --> 00:05:35,560
한 개의 삼각형 만을 그릴 때와 동 일합니다.

79
00:05:35,560 --> 00:05:41,400
그리고 main loop에서 glDrawArrays를 call 할 때

80
00:05:41,400 --> 00:05:46,280
GL_TRIANGLES 의 target으 로 vertex들은 6개 이므로,

81
00:05:46,280 --> 00:05:49,700
마지막 parameter를 6으로 했습니다.

82
00:05:49,700 --> 00:05:54,020
하나의 vertex 좌표가 두 삼각형에서 공유되지만,

83
00:05:54,020 --> 00:05:58,690
이 예제에서는 index를 사용 하지는 않았습니다.

84
00:05:58,690 --> 00:06:03,890
두 번째 예제에서는 두개의 서로 다른 VAO와 VBO들을 사용하여

85
00:06:03,890 --> 00:06:07,040
두개의 삼각 형들을 그려냅니다.

86
00:06:07,040 --> 00:06:11,480
이번에는 두 개의 VBO에 다른 데이터들을 주기 위해

87
00:06:11,480 --> 00:06:17,730
각각 3개씩의 vertex data를 담은 두 개의 array들을 준비했습니다.

88
00:06:17,730 --> 00:06:24,730
VAO와 VBO들 모두 두 개씩 id의 array를 사용하여 generate하였습니다.

89
00:06:24,730 --> 00:06:30,680
그리고 bind, buffering, passing 모두 각각 따로 하였습니다.

90
00:06:30,680 --> 00:06:35,910
주의 할 점은 VAOs[0] 를 먼저 bind하면

91
00:06:35,910 --> 00:06:42,620
그 이후 생성되는 VBO들은 VAOs [0] 에 속하게 되 고,

92
00:06:42,620 --> 00:06:48,300
VAOs[1] 을 bind하면 그 이후 생성되는 VBO들은

93
00:06:48,300 --> 00:06:52,960
VAOs [1] 에 속하게 되는 것입니다.

94
00:06:52,960 --> 00:06:56,700
여기서 glVertexAttribPointer를 사용하여

95
00:06:56,700 --> 00:07:00,160
buffer data를 shader로 passing 할 때

96
00:07:00,160 --> 00:07:05,640
stride를 위쪽에서는 12를 주었고, 아래는 0을 주었는데

97
00:07:05,640 --> 00:07:08,290
이것은 모두 같은 의미입니다.

98
00:07:08,290 --> 00:07:11,340
즉, 데이터 사이에 아무런 다른 공간이 없게

99
00:07:11,340 --> 00:07:14,490
tight하게 packing되어 있을 경우

100
00:07:14,490 --> 00:07:19,510
0을 쓰면 12를 쓴 것과 같은 의미가 된다는 것입니다.

101
00:07:19,510 --> 00:07:22,610
마지막으로 삼각형 두개를 그릴 때

102
00:07:22,610 --> 00:07:26,140
각각 다른 VAO들을 bind한 후

103
00:07:26,140 --> 00:07:33,410
DrawArrays 명령을 불러서 다른 데이터를 사용하도록 합니다.

104
00:07:33,410 --> 00:07:38,790
세번째 예제에서는 두개의 삼각형, orange와 yellow를 그려냅니다.

105
00:07:38,790 --> 00:07:41,320
서로 다른 color를 사용하기 위해

106
00:07:41,320 --> 00:07:47,050
이 예제에서는 두개의 서로 다른 fragment shader를 사용합니다.

107
00:07:47,050 --> 00:07:50,320
fragmentShader1Source string은

108
00:07:50,320 --> 00:07:54,670
orange 색을 사용하는 fragment shader의 소스 입니다.

109
00:07:54,670 --> 00:07:57,380
fragmentShader2Source는

110
00:07:57,380 --> 00:08:02,160
yellow 색을 사용하는 fragment shader의 소스 입 니다.

111
00:08:02,160 --> 00:08:05,840
Shader program 하나는 vertex shader와 fragment shader의

112
00:08:05,840 --> 00:08:08,240
쌍으로 이루어 지기 때문에

113
00:08:08,240 --> 00:08:11,310
다른 fragment shader를 사용하기 위해서는

114
00:08:11,310 --> 00:08:15,110
shader program도 두개가 되어야 합니다.

115
00:08:15,110 --> 00:08:16,390
예전과 달리

116
00:08:16,390 --> 00:08:22,090
yellow fragment shader를 위한 shader object를 하나 더 생성합 니다.

117
00:08:22,090 --> 00:08:25,170
shader의 소스를 읽어 들이고, 컴파일 합니다.

118
00:08:25,170 --> 00:08:30,830
그리하여, 하나의 vertex shader와 orange fragment shader를 결합한

119
00:08:30,830 --> 00:08:34,360
첫번째 shader program이 완성되었습니다.

120
00:08:34,360 --> 00:08:36,880
그리고 나머지 shader program도

121
00:08:36,880 --> 00:08:39,620
같은 vertex shader를 쓰지만

122
00:08:39,620 --> 00:08:43,270
fragment shader는 달리하여 완성되었습니다.

123
00:08:43,270 --> 00:08:48,750
VAO와 VBO는 2번 예제에서 했던 것처럼 두 개씩 만들어서

124
00:08:48,750 --> 00:08:52,170
두 삼각형들에 따로 따로 사용하였습니다.

125
00:08:52,170 --> 00:08:56,620
이 부분에는 변화가 없습니다.

126
00:08:56,620 --> 00:08:58,800
main loop에서 rendering을 할 때,

127
00:08:58,800 --> 00:09:01,420
첫번째 삼각형을 그릴 때에는

128
00:09:01,420 --> 00:09:08,340
shaderProgramOrange를 사용하고, VAOs[0] 를 bind 한 후,

129
00:09:08,340 --> 00:09:10,220
그리면 됩니다.

130
00:09:10,220 --> 00:09:14,860
두번째 삼각형을 위해서는 shaderProgramYellow를 사용하고,

131
00:09:14,860 --> 00:09:18,890
VAOs[1] 을 bind 한 후, 그리면 됩니다.
