1
00:00:00,000 --> 00:00:03,290
Texture Examples 강의입니다.

2
00:00:03,290 --> 00:00:06,660
Texture2 프로그램에서는 사각형 하나에

3
00:00:06,660 --> 00:00:09,600
texture image가 mapping되어 보여집니다.

4
00:00:09,600 --> 00:00:13,180
Space bar를 한번 누를 때마다 texture mode가

5
00:00:13,180 --> 00:00:18,190
1, 2, 3, 0, 1, 2, 3, 0, … 와 같이

6
00:00:18,190 --> 00:00:21,050
반복하여 변하게 됩니다.

7
00:00:21,050 --> 00:00:24,510
그때마다 다른 texture mapping이 적용됩니다.

8
00:00:24,510 --> 00:00:29,510
이 부분은 프로그램에 사용된 rectangle data를 위한

9
00:00:29,510 --> 00:00:34,510
vertex coordinates, vertex color, texture coordinates

10
00:00:34,510 --> 00:00:39,510
데이터들을 담은 세개의 array들을 보여주고 있습니다.

11
00:00:39,510 --> 00:00:42,430
genRectangle 함수는 VBO에

12
00:00:42,430 --> 00:00:45,820
vertex position, color, texture coordinates의

13
00:00:45,820 --> 00:00:49,300
세가지 attribute들을 채우는 부분입니다.

14
00:00:49,300 --> 00:00:52,730
cube 때와 유사하게 glBufferData와

15
00:00:52,730 --> 00:00:55,270
glBufferSubData를 사용하여

16
00:00:55,270 --> 00:00:59,360
각 데이터들을 VBO로 copy하였습니다.

17
00:00:59,360 --> 00:01:02,070
texture가 사용된 object를 그리기 전에,

18
00:01:02,070 --> 00:01:05,990
원하는 texture를 binding 합니다.

19
00:01:05,990 --> 00:01:09,870
texCoordState 가 mode 0 일때

20
00:01:09,870 --> 00:01:13,010
사각형의 4개 vertex들은 0과 1인

21
00:01:13,010 --> 00:01:17,100
정상적인 texture coordinates들을 가집니다.

22
00:01:17,100 --> 00:01:20,250
이미지 전체가 사각형과 딱 맞도록,

23
00:01:20,250 --> 00:01:22,840
texture mapping이 이루어 집니다.

24
00:01:22,840 --> 00:01:25,050
Texture coordinates를 바꾸고

25
00:01:25,050 --> 00:01:27,890
이를 VBO에 덮어쓰기 위해

26
00:01:27,890 --> 00:01:31,380
genRectangle() 함수를 다시 call하였습니다.

27
00:01:31,380 --> 00:01:35,670
그러나 사실 texture coordinates들만 바뀌었기 때문에

28
00:01:35,670 --> 00:01:39,540
genRectangle() 전체를 실행할 필요는 없습니다.

29
00:01:39,540 --> 00:01:41,830
texture coordinates를 쓰는 부분만

30
00:01:41,830 --> 00:01:46,780
glBufferSubData로 다시 써 주면 되겠습니다.

31
00:01:46,780 --> 00:01:50,930
mode 1 에서는 사각형의 vertex들이 가지는

32
00:01:50,930 --> 00:01:55,240
texture coordinates를 그림과 같이 지정하였습니다.

33
00:01:55,240 --> 00:01:57,670
사각형에는 texture image의

34
00:01:57,670 --> 00:02:01,540
1/4 만 mapping 되어 그려지게 됩니다.

35
00:02:01,540 --> 00:02:06,060
mode 2에서는 그림과 같이 사각형의 vertex들의

36
00:02:06,060 --> 00:02:13,210
texture coordinates를 (-1,0),(2,0),(2,1),(-1,1)로

37
00:02:13,210 --> 00:02:15,420
지정하였습니다.

38
00:02:15,420 --> 00:02:19,060
y방향은 [0,1] 사이로 정상이지만,

39
00:02:19,060 --> 00:02:26,280
x방향은 [-1,0] 부분과 [1,2] 두 부분에

40
00:02:26,280 --> 00:02:31,760
정해진 texture가 없기 때문에 wrapping을 사용해야 합니다.

41
00:02:31,760 --> 00:02:41,760
이미지는 가로가 1/3 로 축소되어 가운데 부분에 들어갑니다.

42
00:02:41,760 --> 00:02:43,620
texture 이미지는 texture coordinates가

43
00:02:43,620 --> 00:02:48,480
[0,1] 인 부분에 매핑되어야 하기 때문입니다.

44
00:02:48,480 --> 00:02:51,340
나머지 왼쪽과 아랬쪽 부분은

45
00:02:51,340 --> 00:02:53,620
s방향의 wrapping option이

46
00:02:53,620 --> 00:02:55,940
GL_REPEAT로 되어 있으니

47
00:02:55,940 --> 00:02:59,340
원래 이미지를 반복하게 됩니다.

48
00:02:59,340 --> 00:03:02,070
mode 3에서는 가로와 세로 방향의

49
00:03:02,070 --> 00:03:04,970
texture coordinates의 범위가 모두

50
00:03:04,970 --> 00:03:08,440
[-1,2] 사이로 주어 졌습니다.

51
00:03:08,440 --> 00:03:11,220
따라서 정상적인 teture mapping은

52
00:03:11,220 --> 00:03:17,350
가로 세로 [0,1] x [0,1] 인 부분에만 이루어지며,

53
00:03:17,350 --> 00:03:23,050
나머지 부분들은 모두 wrapping option에 의해 결정됩니다.

54
00:03:23,050 --> 00:03:25,740
앞페이지에서 확인한 바와 같이

55
00:03:25,740 --> 00:03:31,020
s와 t방향의 wrapping option이 모두 GL_REPEAT 이므로

56
00:03:31,020 --> 00:03:35,620
결국 그림과 같은 결과가 나오게 됩니다.

57
00:03:35,620 --> 00:03:39,110
MultiTexture 프로그램은 두 개의 texture map을

58
00:03:39,110 --> 00:03:43,600
동시에 같은 위치에 mapping하는 프로그램 입니다.

59
00:03:43,600 --> 00:03:48,200
두 개의 texture image "container.bmp"와

60
00:03:48,200 --> 00:03:52,470
"awesomeface.bmp"를 각각 load하여

61
00:03:52,470 --> 00:03:57,830
texture1과 texture2 object를 만들었습니다.

62
00:03:57,830 --> 00:04:00,380
두 개의 texture들을 load한 후,

63
00:04:00,380 --> 00:04:04,050
이들을 각각 0, 1번으로 지칭하여

64
00:04:04,050 --> 00:04:07,430
fragment shader로 pass하였습니다.

65
00:04:07,430 --> 00:04:11,470
이 번호를 "texture unit" 이라 부릅니다.

66
00:04:11,470 --> 00:04:13,800
Fragment shader 내에서

67
00:04:13,800 --> 00:04:17,880
각 texture를 받는 uniform variable들의 이름은

68
00:04:17,880 --> 00:04:19,940
각각 texture1과 texture2 입니다.

69
00:04:19,940 --> 00:04:25,100
Application program에서 passing한

70
00:04:25,100 --> 00:04:26,920
texture unit들은

71
00:04:26,920 --> 00:04:28,710
fragment shader 내에서

72
00:04:28,710 --> 00:04:34,570
uniform sampler2D 변수로 받아집니다.

73
00:04:34,570 --> 00:04:36,970
유틸리티 함수인 "mix" 를 이용하여,

74
00:04:36,970 --> 00:04:39,670
texture1과 texture2를

75
00:04:39,670 --> 00:04:43,870
0.8:0.2 의 비율로 color들을 섞어,

76
00:04:43,870 --> 00:04:47,870
최종 color인 FragColor를 계산합니다.

77
00:04:47,870 --> 00:04:53,070
Draw 하기 전에 사용할 texture를 binding해야 하는데,

78
00:04:53,070 --> 00:04:56,970
이 예제에서는 texture들 두 개를 사용해야 하므로,

79
00:04:56,970 --> 00:04:59,470
둘 다 biding을 해 주어야 합니다.

80
00:04:59,470 --> 00:05:03,140
그래서 glActiveTexture()로

81
00:05:03,140 --> 00:05:06,820
먼저 하나의 texture unit을 activate하고

82
00:05:06,820 --> 00:05:09,390
그 texture를 binding한 후,

83
00:05:09,390 --> 00:05:11,960
다음 것으로 진행하게 됩니다.

84
00:05:11,960 --> 00:05:16,930
glActiveTexture에서 사용하는 constant들인

85
00:05:16,930 --> 00:05:21,080
GL_TEXTURE0, GL_TEXTURE1, ... 등은

86
00:05:21,080 --> 00:05:25,150
각각 texture unit들 0, 1, 2, ... 를

87
00:05:25,150 --> 00:05:28,480
순서대로 나타낸다고 보면 됩니다.

88
00:05:28,480 --> 00:05:31,430
OpenGL specification에는

89
00:05:31,430 --> 00:05:35,500
최소 16개 이상의 texture unit을

90
00:05:35,500 --> 00:05:38,540
지원하도록 되어 있습니다.

91
00:05:38,540 --> 00:05:40,980
Texture unit 상수들은

92
00:05:40,980 --> 00:05:43,400
연속적인 값들을 가지기 때문에

93
00:05:43,400 --> 00:05:46,940
간단한 연산을 통해 지정될 수도 있습니다.

94
00:05:46,940 --> 00:05:49,770
예를 들면, GL_TEXTURE8 은

95
00:05:49,770 --> 00:05:53,380
(GL_TEXTURE0 + 8) 과 같습니다.

96
00:05:53,380 --> 00:05:57,000
이 성질을 사용하면 loop를 이용하여

97
00:05:57,000 --> 00:06:01,190
texture들을 binding하는 것이 가능해 집니다.

98
00:06:01,190 --> 00:06:04,840
ColorTexture 프로그램은 vertex color와

99
00:06:04,840 --> 00:06:07,340
texture mapping을 동시에 활용하여

100
00:06:07,340 --> 00:06:09,030
렌더링하는 프로그램 입니다.

101
00:06:09,030 --> 00:06:12,870
이 프로그램에서는, fragment shader에서,

102
00:06:12,870 --> 00:06:16,550
주어진 vertex color와 texture color를 곱해서

103
00:06:16,550 --> 00:06:19,580
최종 color를 계산하게 합니다.

104
00:06:19,580 --> 00:06:24,280
모든 color 값들이 [0,1] 범위이기 때문에

105
00:06:24,280 --> 00:06:29,010
그들을 곱한 값도 [0, 1] 범위에 존재하게 됩니다.
