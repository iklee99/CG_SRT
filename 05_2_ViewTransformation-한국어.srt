1
00:00:00,000 --> 00:00:05,700
이 note에서는 world space를 view space로 변환하는

2
00:00:05,700 --> 00:00:10,270
view transformation의 구현에 대해 자세히 알아봅니다.

3
00:00:10,270 --> 00:00:13,430
이 과정을 통해 glm::lookAt 함수가

4
00:00:13,430 --> 00:00:17,530
어떻게 구현되었는지를 알 수 있습니다.

5
00:00:17,530 --> 00:00:22,050
Computer graphics에서 camera는 중요한 역할을 합니다.

6
00:00:22,050 --> 00:00:26,420
같은 object들이 3D world에 고정되어 있다 하더라도

7
00:00:26,420 --> 00:00:29,660
그 object들을 어떻게 바라보는가에 따라

8
00:00:29,660 --> 00:00:32,940
최종 ouput image는 달라지게 됩니다.

9
00:00:32,940 --> 00:00:35,950
이것은 마치 인물 사진을 찍을 때,

10
00:00:35,950 --> 00:00:39,640
카메라의 위치와 방향을 어떻게 하느냐에 따라,

11
00:00:39,640 --> 00:00:41,470
같은 인물을 찍더라도

12
00:00:41,470 --> 00:00:45,490
찍힌 사진이 달라지게 되는 것과 같습니다.

13
00:00:45,490 --> 00:00:48,060
그림은 Unity 게임 엔진의

14
00:00:48,060 --> 00:00:52,220
game view와 working view를 보여주고 있습니다.

15
00:00:52,220 --> 00:00:55,170
이 두가지 view들에 사용된 camera들은

16
00:00:55,170 --> 00:00:57,630
서로 다른 것입니다.

17
00:00:57,630 --> 00:01:01,010
working view에서 흰색으로 표시된 카메라를

18
00:01:01,010 --> 00:01:05,600
어느 위치에 두고 어디를 바라보게 하느냐에 따라,

19
00:01:05,600 --> 00:01:09,360
위쪽 game view에서 실제 game에 보이는 scene은

20
00:01:09,360 --> 00:01:10,820
달라지게 됩니다.

21
00:01:10,820 --> 00:01:14,880
working view의 흰색 카메라 아이콘의 방향은

22
00:01:14,880 --> 00:01:18,040
실제 카메라가 바라보는 방향은 아닙니다.

23
00:01:18,040 --> 00:01:22,550
다만 카메라의 아이콘이 그 방향으로 고정되어 있기 때문에

24
00:01:22,550 --> 00:01:24,860
그렇게 표시되는 것입니다.

25
00:01:24,860 --> 00:01:29,540
여기서 카메라는 두 개의 구 쪽을 바라보고 있고,

26
00:01:29,540 --> 00:01:35,100
그 때문에 위쪽 윈도우의 game view를 볼 수 있게 됩니다.

27
00:01:35,100 --> 00:01:37,520
이전에 언급했듯이, OpenGL에서의

28
00:01:37,520 --> 00:01:41,330
카메라는 항상 origin에 위치하고

29
00:01:41,330 --> 00:01:43,820
-z 방향을 바라보고 있습니다.

30
00:01:43,820 --> 00:01:47,990
이 위치와 방향을 우리는 바꿀 수 없습니다.

31
00:01:47,990 --> 00:01:51,840
그러면 원하는 위치와 방향으로 카메라를 옮겨서

32
00:01:51,840 --> 00:01:56,860
원하는 뷰를 볼 수 있게 하려면 어떻게 해야 할까요?

33
00:01:56,860 --> 00:02:00,760
그것은 camera의 motion을 simulation하는 것입니다.

34
00:02:00,760 --> 00:02:05,130
즉, 현재 view에 보이는 object를 camera motion의

35
00:02:05,130 --> 00:02:07,370
반대방향으로 움직임으로써

36
00:02:07,370 --> 00:02:11,310
camera가 움직이는 것처럼 느끼게 하는 것입니다.

37
00:02:11,310 --> 00:02:15,360
이것은 영화 촬영 때 기차 내부 set를 만들었을 때,

38
00:02:15,360 --> 00:02:18,880
창 밖의 나무들을 움직이게 하면,

39
00:02:18,880 --> 00:02:22,580
기차가 가고 있는 느낌을 주는 것과 같습니다.

40
00:02:22,580 --> 00:02:25,860
다시 말하면, camera를 배치하는 대신에

41
00:02:25,860 --> 00:02:32,030
반대로 object들을 배치하자는 아이디어 입니다.

42
00:02:32,030 --> 00:02:34,500
Camera space를 정의하기 위해

43
00:02:34,500 --> 00:02:36,490
camera의 각종 parameter들을

44
00:02:36,490 --> 00:02:39,200
world space 상에서 정의합니다.

45
00:02:39,200 --> 00:02:42,950
우리가 잘 알고 있는 world coordinate system은

46
00:02:42,950 --> 00:02:47,260
서로 수직인 x, y, z축들을 basis로 가지고 있으며,

47
00:02:47,260 --> 00:02:49,390
오른손 좌표계 입니다.

48
00:02:49,390 --> 00:02:52,910
즉, z축의 양의 방향이 screen으로부터

49
00:02:52,910 --> 00:02:55,620
우리 쪽을 향하고 있습니다.

50
00:02:55,620 --> 00:02:57,430
Camera를 정의하기 위해

51
00:02:57,430 --> 00:03:01,120
몇 개의 중요한 parameter들을 정의합니다.

52
00:03:01,120 --> 00:03:04,570
P는 camera의 위치로 Center Of Projection,

53
00:03:04,570 --> 00:03:07,780
줄여서 COP라 불립니다.

54
00:03:07,780 --> 00:03:12,420
A는 카메라가 바라보고 있는 target point를 나타내는데,

55
00:03:12,420 --> 00:03:16,090
여기서는 "at point" 라 부르겠습니다.

56
00:03:16,090 --> 00:03:18,210
V는 up vector인데,

57
00:03:18,210 --> 00:03:21,890
그림에서 보듯 camera의 머리 위쪽 방향을 나타내는

58
00:03:21,890 --> 00:03:23,940
vector 입니다.

59
00:03:23,940 --> 00:03:26,860
이제 위의 parameter들을 이용하여

60
00:03:26,860 --> 00:03:33,570
view (camera, eye) coordinate system 을 정의해 보겠습니다.

61
00:03:33,570 --> 00:03:38,560
이 좌표계의 세 축들, UVN,을 구할 것입니다.

62
00:03:38,560 --> 00:03:42,010
U는 camera의 오른쪽 방향의 축 vector인데,

63
00:03:42,010 --> 00:03:45,790
일반적인 좌표계로 보면 x축에 해당합니다.

64
00:03:45,790 --> 00:03:49,120
V는 아까 정의한 것과 같이 camera의 위쪽,

65
00:03:49,120 --> 00:03:52,730
즉, y쪽 방향을 나타내는 축 vector입니다.

66
00:03:52,730 --> 00:03:57,440
마지막으로 N은 camera가 바라보고 있는 방향의 축을 나타내는데,

67
00:03:57,440 --> 00:04:01,240
일반적인 좌표계의 +z축에 해당합니다.

68
00:04:01,240 --> 00:04:06,220
N vector는 P로부터 A로 가는 vector가 됩니다.

69
00:04:06,220 --> 00:04:10,990
또한, N은 view plane의 normal vector와 같습니다.

70
00:04:10,990 --> 00:04:17,580
그런데, 그림에서 보면 +N 방향이 world space와 반대이고,

71
00:04:17,580 --> 00:04:22,520
+N 방향이 우리 쪽으로부터 화면의 안쪽 방향을 향하고 있습니다.

72
00:04:22,520 --> 00:04:24,920
즉 view coordinate system은

73
00:04:24,920 --> 00:04:27,600
왼손 좌표계라 할 수 있습니다.

74
00:04:27,600 --> 00:04:33,220
이러한 UVN의 정의를 바탕으로 실제 UVN을 구하는 방법을

75
00:04:33,220 --> 00:04:36,640
다음 슬라이드에서 살펴 보기로 합니다.

76
00:04:36,640 --> 00:04:41,130
이제 주어진 camera parameter들 P, A, V로부터

77
00:04:41,130 --> 00:04:45,040
UVN 축들을 계산하는 방법을 살펴보도록 합니다.

78
00:04:45,040 --> 00:04:47,710
먼저 up vector V 대신에,

79
00:04:47,710 --> 00:04:51,960
parameter로 virtual up vector v' 이 주어졌다고

80
00:04:51,960 --> 00:04:54,010
가정하겠습니다.

81
00:04:54,010 --> 00:04:57,650
v'은 정확한 V 방향 vector가 아닌

82
00:04:57,650 --> 00:05:02,310
대략적인 up 방향을 나타내는 근사치의 vector입니다.

83
00:05:02,310 --> 00:05:06,930
사실, P로부터 A로 가는 방향의 vector가 N 인데,

84
00:05:06,930 --> 00:05:09,890
N과 V는 서로 수직 이어야 합니다.

85
00:05:09,890 --> 00:05:13,580
그러나 이런 vector를 user가 직접 계산해서

86
00:05:13,580 --> 00:05:17,860
camera parameter로 입력하기는 쉽지 않습니다.

87
00:05:17,860 --> 00:05:21,040
따라서 대충 비슷한 v'을 주고,

88
00:05:21,040 --> 00:05:26,110
정확한 V를 프로그램이 계산하도록 하는 것입니다.

89
00:05:26,110 --> 00:05:28,770
많은 경우에 world space의 y축

90
00:05:28,770 --> 00:05:32,800
(0, 1, 0)이 v'로 사용됩니다.

91
00:05:32,800 --> 00:05:36,350
물론 camera를 거꾸로 들고 있는 경우라면

92
00:05:36,350 --> 00:05:39,650
–y 축이 더 나을 수도 있겠습니다.

93
00:05:39,650 --> 00:05:42,300
N의 계산은 가장 쉽습니다.

94
00:05:42,300 --> 00:05:47,580
P로부터 A로 가는 vector A – P 를 small n이라 하면,

95
00:05:47,580 --> 00:05:53,550
n을 normalize하면 N이 됩니다.

96
00:05:53,550 --> 00:05:57,150
U vector는 V와 N에 모두 수직입니다.

97
00:05:57,150 --> 00:06:02,510
우리는 n과 v'을 cross product하여 small u를 구하고,

98
00:06:02,510 --> 00:06:05,930
이를 normalize하여 U를 구합니다.

99
00:06:05,930 --> 00:06:09,680
좀 자세히 보면 이상한 점을 발견할 수 있는데요.

100
00:06:09,680 --> 00:06:13,180
UVN 좌표계 이므로 U를 구하려면

101
00:06:13,180 --> 00:06:17,370
N x V가 아니라 V x N을 해야 하는게 아닌가

102
00:06:17,370 --> 00:06:19,730
하는 생각이 들 것입니다.

103
00:06:19,730 --> 00:06:23,310
그런데 그것은 오른손 좌표계의 경우입니다.

104
00:06:23,310 --> 00:06:29,240
앞에서 보았듯이 camera space UVN은 왼손 좌표계이기 때문에

105
00:06:29,240 --> 00:06:31,420
V x N 의 반대 방향인

106
00:06:31,420 --> 00:06:35,940
N x V를 계산하여 U를 구하였습니다.

107
00:06:35,940 --> 00:06:38,860
이제 N과 U가 정해졌으니까,

108
00:06:38,860 --> 00:06:41,920
정확한 V를 구할 수 있습니다.

109
00:06:41,920 --> 00:06:45,020
u x n을 하여 v를 구하고

110
00:06:45,020 --> 00:06:50,660
이를 normalize하면 V가 됩니다.

111
00:06:50,660 --> 00:06:55,020
위와 마찬가지로 오른손 좌표계와는 반대 방향으로

112
00:06:55,020 --> 00:06:57,660
cross product를 계산하기 때문에

113
00:06:57,660 --> 00:07:03,040
n x u 가 아니라 u x n을 계산합니다.

114
00:07:03,040 --> 00:07:06,400
View space의 UVN 축이 결정되었으면,

115
00:07:06,400 --> 00:07:11,430
world space에서 view space로의 좌표변환이 가능해 집니다.

116
00:07:11,430 --> 00:07:14,050
이제 우리는 바로 앞 노트

117
00:07:14,050 --> 00:07:18,290
05_1_Transformation Pipeline 에서 언급했던

118
00:07:18,290 --> 00:07:21,750
view matrix를 결정할 수 있게 되었습니다.

119
00:07:21,750 --> 00:07:26,210
먼저 앞에서 설명한 방법으로 U, V, N이 구해졌습니다.

120
00:07:26,210 --> 00:07:29,730
또 COP P의 좌표도 주어졌습니다.

121
00:07:29,730 --> 00:07:33,670
이 때 P와 UVN의 모든 좌표들은

122
00:07:33,670 --> 00:07:37,020
world space를 기준으로 표현된 것입니다.

123
00:07:37,020 --> 00:07:41,150
또, 모든 UVN은 모두 unit vector들입니다.

124
00:07:41,150 --> 00:07:44,620
이전에 공부한 change-of-frame 에 따르면,

125
00:07:44,620 --> 00:07:48,900
view coordinates로 부터 world coordinates로 변환하는

126
00:07:48,900 --> 00:07:53,410
transformation T_cw는 이와 같이 주어집니다.

127
00:07:53,410 --> 00:08:01,550
T_cw = T_p R 인데, UVN vector들과 P의 coordinates를

128
00:08:01,550 --> 00:08:04,180
matrix의 각 column으로 배치하는

129
00:08:04,180 --> 00:08:10,840
일반적인 “rotation-before-translation" 형태의 matrix 입니다.

130
00:08:10,840 --> 00:08:18,880
우리의 원래 목표는 위와 반대 방향인 "world to view space" 였으므로,

131
00:08:18,880 --> 00:08:26,380
T_wc matrix는 T_cw의 inverse를 이와 같이 구하면 됩니다.

132
00:08:26,380 --> 00:08:31,090
Rotation matrix의 inverse는 그 matrix의 transpose와 같고,

133
00:08:31,090 --> 00:08:33,300
translation matrix의 inverse는

134
00:08:33,300 --> 00:08:37,200
벡터 방향을 반대로 하면 된다는 것을 기억하면

135
00:08:37,200 --> 00:08:41,180
쉽게 이해할 수 있습니다.

136
00:08:41,180 --> 00:08:45,150
앞에서 설명한 과정을 실제 예로 살펴보도록 합니다.

137
00:08:45,150 --> 00:08:48,870
계산을 간단히 하기 위해 COP인 P는

138
00:08:48,870 --> 00:08:52,190
world coordinates로 (0, 0, 5)

139
00:08:52,190 --> 00:08:54,830
즉 +z 축 상에 있고,

140
00:08:54,830 --> 00:08:58,850
camera는 현재 world space의 원점을 보고 있다고,

141
00:08:58,850 --> 00:09:04,040
즉, A = (0, 0, 0) 라고 가정하겠습니다.

142
00:09:04,040 --> 00:09:09,310
또, up vector는 그냥 y축과 같다고 가정해 보겠습니다.

143
00:09:09,310 --> 00:09:11,940
그림을 참고하기 바랍니다.

144
00:09:11,940 --> 00:09:17,560
먼저 n = A - P 이므로 N = (0, 0, -1),

145
00:09:17,560 --> 00:09:23,170
즉 world의 -z축이 됩니다.

146
00:09:23,170 --> 00:09:29,620
u = n x v' 이므로 U = (1, 0, 0),

147
00:09:29,620 --> 00:09:33,440
즉 world의 x축과 같습니다.

148
00:09:33,440 --> 00:09:39,660
마지막으로 v = u x n 을 계산해 보면

149
00:09:39,660 --> 00:09:46,430
역시 처음 가정 했듯이 v는 world의 y축이 됩니다.

150
00:09:46,430 --> 00:09:51,890
이제 world space의 한 점 Q_w = (3, 3, -1)을

151
00:09:51,890 --> 00:09:54,890
view coordinates로 바꾸어 보겠습니다.

152
00:09:54,890 --> 00:09:56,980
앞의 slide에서 유도한 것처럼,

153
00:09:56,980 --> 00:09:59,950
view coordinates Q_c는

154
00:09:59,950 --> 00:10:04,130
T_wc matrix와 Q_w의 곱과 같습니다.

155
00:10:04,130 --> 00:10:07,600
이 식을 모두 기억할 수 있을 것입니다.

156
00:10:07,600 --> 00:10:12,990
여기에 바로 앞장에서 계산한 UVN과 P 좌표값들을 넣어주면,

157
00:10:12,990 --> 00:10:16,830
Q_c 는 (3, 3, 6, 1) 이 나옵니다.

158
00:10:16,830 --> 00:10:21,890
사실 이 좌표 변환은 계산 없이도 직관적으로 가능합니다.

159
00:10:21,890 --> 00:10:26,100
Camera가 world +z 축의 (0, 0, 5) 에 있고

160
00:10:26,100 --> 00:10:28,630
원점을 바라보고 있으므로,

161
00:10:28,630 --> 00:10:34,090
Q_w의 z좌표 -1 은 Q_c에서 6이 될 것입니다.

162
00:10:34,090 --> 00:10:38,470
나머지 U와 V는 변화없이 3으로 남아 있다는 것도

163
00:10:38,470 --> 00:10:43,080
쉽게 이해할 수 있을 것입니다.

164
00:10:43,080 --> 00:10:49,330
이번 예제에서는 COP의 좌표를 (1, -1, 5)로 약간 바꾸었습니다.

165
00:10:49,330 --> 00:10:52,400
이렇게 하면 view space는 약간 비틀어 지고,

166
00:10:52,400 --> 00:10:55,590
N, U, V 축들도 바뀌게 됩니다.

167
00:10:55,590 --> 00:11:00,130
계산하는 방법은 이전과 같습니다.

168
00:11:00,130 --> 00:11:03,410
이러한 과정으로 world에서 view space로 변환하는

169
00:11:03,410 --> 00:11:06,620
transformation matrix를 계산하는 함수가

170
00:11:06,620 --> 00:11:09,710
glm::lookAt 입니다.

171
00:11:09,710 --> 00:11:13,220
Parameter들로는 COP (P), target (A),

172
00:11:13,220 --> 00:11:19,660
virtual_up_vector(v')이 주어지게 됩니다.

173
00:11:19,660 --> 00:11:24,280
이 프로그램은 cube를 "model transformation" 하는 것이 아니라

174
00:11:24,280 --> 00:11:27,740
camera의 위치를 cube를 둘러싸고 있는

175
00:11:27,740 --> 00:11:30,650
원형 pass를 따라 움직이게 하여

176
00:11:30,650 --> 00:11:34,450
cube가 도는 것처럼 보이게 합니다.

177
00:11:34,450 --> 00:11:37,170
Camera는 항상 cube의 중심인 원점을

178
00:11:37,170 --> 00:11:39,290
target으로 보고 있습니다.

179
00:11:39,290 --> 00:11:41,010
우리는 이 프로그램에서

180
00:11:41,010 --> 00:11:44,780
glm::lookAt 함수를 사용합니다.

181
00:11:44,780 --> 00:11:48,750
Projection matrix는 main()에서 setting합니다.

182
00:11:48,750 --> 00:11:52,970
projection matrix는 프로그램 수행 동안 변하지 않기 때문에

183
00:11:52,970 --> 00:11:56,690
main에서 한번만 setting해 주면 됩니다.

184
00:11:56,690 --> 00:12:00,300
Model matrix는 identity로 그냥 남겨두어서

185
00:12:00,300 --> 00:12:03,660
cube에는 아무런 변화가 없습니다.

186
00:12:03,660 --> 00:12:06,680
Camera의 위치인 COP는 시간에 따라

187
00:12:06,680 --> 00:12:11,820
xz 평면에 평행한 궤도를 따라 움직입니다.

188
00:12:11,820 --> 00:12:14,980
원형궤도의 반지름은 5입니다.

189
00:12:14,980 --> 00:12:18,570
glm::lookAt 함수에 주어지는 COP의 좌표는

190
00:12:18,570 --> 00:12:23,030
(camX, 1.5, camZ)로 주어집니다.

191
00:12:23,030 --> 00:12:26,840
즉, 카메라는 xz 평면과 평행하게

192
00:12:26,840 --> 00:12:30,670
y 방향으로 약간 떠 있습니다.

193
00:12:30,670 --> 00:12:33,510
카메라의 렌즈는 약간 아래로 기울어져서

194
00:12:33,510 --> 00:12:35,700
원점을 쳐다보고 있습니다.

195
00:12:35,700 --> 00:12:39,420
즉 at point A는 원점으로 주어졌습니다.

196
00:12:39,420 --> 00:12:44,970
Virtual up vector인 v'은 world의 y축으로 주어져서

197
00:12:44,970 --> 00:12:51,340
glm::lookAt이 정확한 V vector를 계산할 수 있도록 해 줍니다.
