1
00:00:05,000 --> 00:00:09,000
컴퓨터그래픽스는 컴퓨터에서 시각적 개체를 만들고,

2
00:00:09,000 --> 00:00:14,000
조작하고, 사용하는 데 관련된 학문으로, 줄여서 CG라 부릅니다.

3
00:00:14,000 --> 00:00:19,000
흔히 컴퓨터그래픽스를 Blender, 3DMax, Photoshop과 같은

4
00:00:19,000 --> 00:00:24,000
소프트웨어를 이용하여 그림을 그려내는 것이라 생각하기 쉽습니다.

5
00:00:24,000 --> 00:00:27,000
그러나 컴퓨터 과학에서 컴퓨터그래픽스는

6
00:00:27,000 --> 00:00:32,000
그래픽 객체를 생성하기 위한 소프트웨어를 개발하는 기술을 말합니다.

7
00:00:32,000 --> 00:00:37,000
컴퓨터그래픽스의 세부 분야들은 크게 세가지로 분류됩니다.

8
00:00:37,000 --> 00:00:43,000
“모델링”은 컴퓨터 안에 기하학적인 오브젝트를 표현하는 방법에 관한 분야로서,

9
00:00:43,000 --> 00:00:47,000
수학적 표현이나 데이터구조와 관련되어 있습니다.

10
00:00:47,000 --> 00:00:52,000
“렌더링"은 모델링된 오브젝트를 화면에 그려내는 방법에 관한 분야로서,

11
00:00:52,000 --> 00:00:57,000
실제 세계와 똑같이 그려내기 위한 Photorealistic 렌더링과

12
00:00:57,000 --> 00:01:02,000
다른 예술적 작업 방식을 모사한 Non-Photorealistic Rendering 등

13
00:01:02,000 --> 00:01:04,000
여러가지 방식들이 있습니다.

14
00:01:04,000 --> 00:01:09,000
시간을 변화시키면서 한 프레임, 즉, 한 장면씩을 렌더링한 결과를

15
00:01:09,000 --> 00:01:13,000
연속적으로 보여줌으로써 애니메이션이 가능해 집니다.

16
00:01:13,000 --> 00:01:17,000
시간에 따른 오브젝트의 궤적 또는 모양의 변화를 계산해 나가는

17
00:01:17,000 --> 00:01:22,000
기술을 연구하는 분야를 “애니메이션” 분야라 부릅니다.

18
00:01:22,000 --> 00:01:26,000
CG와 관련된 분야로 이미지나 비디오를 가공하는

19
00:01:26,000 --> 00:01:29,000
“image/video processing” 이 있습니다.

20
00:01:29,000 --> 00:01:32,000
특히 카메라로 촬영된 사진이나 비디오를

21
00:01:32,000 --> 00:01:35,000
특별한 용도에 맞게 가공하는 분야를

22
00:01:35,000 --> 00:01:38,000
"Computational Photography" 라 부릅니다.

23
00:01:38,000 --> 00:01:42,000
"인간과 컴퓨터 상호작용(Human-Computer Interaction)” 은

24
00:01:42,000 --> 00:01:45,000
흔히 “HCI” 라고 줄여 부르는데,

25
00:01:45,000 --> 00:01:48,000
인간이 컴퓨팅 장치를 이용하는데 관련된

26
00:01:48,000 --> 00:01:52,000
디바이스나 상호작용 방식을 연구하는 분야입니다.

27
00:01:52,000 --> 00:01:56,000
“가시화 (Visualization)” 는 흔히

28
00:01:56,000 --> 00:02:00,000
“과학 가시화(Scientific Visualization)” 과

29
00:02:00,000 --> 00:02:06,000
“정보 가시화(Information Visualization)” 의 두 분야로 분류되는데,

30
00:02:06,000 --> 00:02:10,000
초기 CG의 응용 분야로 많이 고려되던 분야입니다.

31
00:02:10,000 --> 00:02:18,000
“가상현실(VR, Virtual Reality)” 과 “증강현실(AR, Augmented Reality)” 등을

32
00:02:18,000 --> 00:02:23,000
함께 아우르는 “확장 현실(XR, Extended Reality)”은

33
00:02:23,000 --> 00:02:28,000
최근에 CG의 응용분야로 가장 주목받고 있는 분야들 중 하나입니다.

34
00:02:28,000 --> 00:02:32,000
“3D 프린팅” 은 컴퓨터로 모델링된 오브젝트를

35
00:02:32,000 --> 00:02:37,000
실제 세계의 재료들로 생산해 내는 과정을 일컫는 것으로,

36
00:02:37,000 --> 00:02:42,000
역시 최근에 가장 빠르게 발전하고 있는 분야들 중 하나 입니다.

37
00:02:42,000 --> 00:02:47,000
CG의 응용분야로 가장 유명한 것은 영화 제작입니다.

38
00:02:47,000 --> 00:02:53,000
요즘에는 실사 촬영과 CG 화면을 합성하여 영화를 제작하는 것이 일반적인데,

39
00:02:53,000 --> 00:02:57,000
이러한 방식으로 현실에 존재하지 않는 장면들을

40
00:02:57,000 --> 00:03:00,000
비교적 작은 비용으로 만들어 낼 수 있습니다.

41
00:03:00,000 --> 00:03:04,000
다만 현실과 구분하기 어려울 정도의 정교한 그래픽스 결과를

42
00:03:04,000 --> 00:03:08,000
만들어 내기 위해서는 한 프레임에 수분, 수시간,

43
00:03:08,000 --> 00:03:12,000
때로는 수일이나 걸리는 컴퓨팅이 필요할 수 있습니다.

44
00:03:12,000 --> 00:03:15,000
다른 응용분야로는 게임이 있습니다.

45
00:03:15,000 --> 00:03:20,000
특히 게임에서는 실시간으로 장면들을 렌더링 하는 것이 필수적입니다.

46
00:03:20,000 --> 00:03:25,000
실시간 그래픽스에서는 일반적으로 1초에 최소 30프레임 이상의

47
00:03:25,000 --> 00:03:28,000
렌더링 속도가 보장되어야 하기 때문에,

48
00:03:28,000 --> 00:03:34,000
렌더링 결과의 품질과 렌더링 계산의 속도의 균형을 맞추는 것이 필요합니다.

49
00:03:34,000 --> 00:03:38,000
요즘에는 Unity, Unreal 과 같은 게임 엔진들이 개발되어,

50
00:03:38,000 --> 00:03:40,000
게임 제작이 한결 쉬워 졌는데,

51
00:03:40,000 --> 00:03:46,000
이 게임 엔진들에 사용되는 가장 중요한 기술들 중의 하나가 CG 입니다.

52
00:03:46,000 --> 00:03:52,000
CG 기술은 entertainment 이외에도 다양한 분야들에서 사용되고 있는데,

53
00:03:52,000 --> 00:03:54,000
기계, 건축 등의 설계,

54
00:03:54,000 --> 00:03:57,000
가시화 (Visualization)

55
00:03:57,000 --> 00:04:00,000
비행 시뮬레이터 (Flight Simulator) 등의 교육 훈련용,

56
00:04:00,000 --> 00:04:03,000
그리고 미디어 아트 등에 사용되고 있습니다.

57
00:04:03,000 --> 00:04:07,000
우리가 컴퓨터 화면에 무언가를 그려내기 위해서는

58
00:04:07,000 --> 00:04:12,000
먼저 입력 장치들로 부터 입력을 받아들이는 것이 필요합니다.

59
00:04:12,000 --> 00:04:18,000
우리는 키보드, 태블릿, 마우스 등의 장치들을 사용하여 입력할 수 있습니다.

60
00:04:18,000 --> 00:04:25,000
입력은 먼저 CPU 메모리에 저장된 후. 다양한 방법으로 가공되게 됩니다.

61
00:04:25,000 --> 00:04:30,000
이 데이터는 GPU (Graphics Processing Unit) 안의

62
00:04:30,000 --> 00:04:33,000
GPU memory로 옮겨집니다.

63
00:04:33,000 --> 00:04:38,000
특히, 현재 화면에 그려지는 pixel 값들을 저장하고 있는 memory를

64
00:04:38,000 --> 00:04:40,000
frame buffer라 부릅니다.

65
00:04:40,000 --> 00:04:45,000
Frame buffer의 내용은 매우 빠른 속도로 화면에 계속 그려지게 됩니다.

66
00:04:45,000 --> 00:04:49,000
따라서 frame buffer의 내용을 계속 바꿈으로서,

67
00:04:49,000 --> 00:04:54,000
우리는 움직이는 그림 (애니메이션)을 볼 수 있게 됩니다.

68
00:04:54,000 --> 00:04:57,000
Raster는 pixel들의 집합을 뜻합니다.

69
00:04:57,000 --> 00:05:00,000
Pixel은 picture element의 준말입니다.

70
00:05:00,000 --> 00:05:06,000
하나의 pixel은 하나의 color를 가지며, 화면의 한 좌표를 차지하는 위치를 나타냅니다.

71
00:05:06,000 --> 00:05:11,000
현재 디스플레이되는 raster를 저장하고 있는 frame buffer는 사실

72
00:05:11,000 --> 00:05:14,000
여러 가지 buffer들의 집합을 말합니다.

73
00:05:14,000 --> 00:05:19,000
Frame buffer는 pixel의 color값들을 저장하는 color buffer

74
00:05:19,000 --> 00:05:22,000
깊이 값들을 저장하는 depth buffer등

75
00:05:22,000 --> 00:05:25,000
여러가지 buffer들로 구성되어 있습니다.

76
00:05:25,000 --> 00:05:29,000
Scan conversion은 rasterization이라고도 불리는데,

77
00:05:29,000 --> 00:05:34,000
삼각형과 같은 다각형을 pixel 데이터로 바꾸는 작업을 말합니다.

78
00:05:34,000 --> 00:05:38,000
그림에서 처럼 스크린에 삼각형을 그리기 위해서는

79
00:05:38,000 --> 00:05:43,000
어떤 pixel을 켜고, 꺼야 할지를 결정하는 작업이 필요합니다.

80
00:05:43,000 --> 00:05:48,000
Scan conversion은 CG를 위해 GPU가 전담하는 작업들 중의 하나 입니다.

81
00:05:48,000 --> 00:05:53,000
GPU는 frame buffer 와 같은 graphical memory를 가지고 있으며,

82
00:05:53,000 --> 00:05:57,000
CG에 필요한 특별한 알고리즘들을 H/W로 구현하여

83
00:05:57,000 --> 00:05:59,000
빠르게 실행되도록 하고 있습니다.

84
00:05:59,000 --> 00:06:05,000
GPU는 원래 CG를 위해 개발되었으나 최근에는 계산량이 많은 기계학습,

85
00:06:05,000 --> 00:06:08,000
전자화폐 채굴 등에도 널리 사용됩니다.

86
00:06:08,000 --> 00:06:13,000
뒤에서 설명할 flat-pannel display가 출현하기 전까지

87
00:06:13,000 --> 00:06:20,000
가장 많이 사용되던 출력 장치가 바로 CRT (Cathode-Ray-Tube) 입니다.

88
00:06:20,000 --> 00:06:23,000
Frame buffer의 내용을 일률적으로 보여주는

89
00:06:23,000 --> 00:06:28,000
raster display 방식이 CRT에 주로 쓰였습니다.

90
00:06:28,000 --> 00:06:32,000
CRT의 전자총에서 발사된 전자의 경로는

91
00:06:32,000 --> 00:06:36,000
XY 편향기들에 자기력에 의해 구부러져서

92
00:06:36,000 --> 00:06:39,000
스크린의 원하는 좌표에 도달합니다.

93
00:06:39,000 --> 00:06:45,000
CRT 스크린 표면에는 빛을 내는 형광물질 (phosphor) 가 칠해져 있어서

94
00:06:45,000 --> 00:06:48,000
전자가 부딛히면 빛을 내게 됩니다.

95
00:06:48,000 --> 00:06:53,000
CRT 화면을 다시 그리는 속도를 refresh rate라 부릅니다.

96
00:06:53,000 --> 00:06:58,000
미국에서는 주로 1초에 60회 다시 그리는 방식이 쓰이는데,

97
00:06:58,000 --> 00:07:01,000
이 속도를 60 헤르쯔라고 부릅니다.

98
00:07:01,000 --> 00:07:06,000
유럽 지역에서는 보통 50 헤르쯔가 많이 쓰입니다.

99
00:07:06,000 --> 00:07:09,000
Refresh 할 때, 한번은 홀수 행만,

100
00:07:09,000 --> 00:07:14,000
다음번에는 짝수 행만 다시 그리는식으로 하는 것을 interacing이라고 합니다.

101
00:07:14,000 --> 00:07:19,000
Interacing을 이용하는 경우, 60Hz의 refresh는

102
00:07:19,000 --> 00:07:23,000
사실 30Hz refresh라고 볼 수 있습니다.

103
00:07:23,000 --> 00:07:26,000
요즘 가장 많이 쓰이는 디스플레이는

104
00:07:26,000 --> 00:07:31,000
Flat-panel display (평판 디스플레이) 입니다.

105
00:07:31,000 --> 00:07:34,000
세로와 가로 두 개의 2D 그리드 사이에

106
00:07:34,000 --> 00:07:39,000
light emitting elements (발광물질)이 들어 있으며,

107
00:07:39,000 --> 00:07:44,000
두개의 그리드를 사용하여 특정 위치에 빛이 보이게 될지를 지정합니다.

108
00:07:44,000 --> 00:07:48,000
Light emitting elements를 만드는 기술에 따라

109
00:07:48,000 --> 00:07:52,000
LCD, LED, OLED 등으로 구분됩니다.

110
00:07:52,000 --> 00:07:57,000
컴퓨터 그래픽스를 위한 입력장치로 다양한 것들이 쓰이고 있습니다.

111
00:07:57,000 --> 00:08:02,000
마우스는 우리가 평소에 많이 쓰는 것으로, 그래픽스에서도 많이 쓰입니다.

112
00:08:02,000 --> 00:08:08,000
trackball 에서는 데이터 입력을 위해 360도 방향으로 자유롭게 돌아가는

113
00:08:08,000 --> 00:08:13,000
ball을 손바닥으로 굴려서, 회전량 등을 입력할때 많이 쓰입니다.

114
00:08:13,000 --> 00:08:18,000
tablet 은 펜을 사용하여 정교한 그림을 그릴 때 자주 사용됩니다.

115
00:08:18,000 --> 00:08:23,000
요즘은 화면에 직접 터치펜으로 그리는 고가의 태블릿도 자주 사용됩니다.

116
00:08:23,000 --> 00:08:27,000
조이스틱은 게임 플레이 같은 때 자주 쓰이는 것입니다.

117
00:08:27,000 --> 00:08:32,000
스페이스볼은 트랙볼과 용도가 비슷하지만, 공을 굴리는 것이 아니라

118
00:08:32,000 --> 00:08:37,000
손으로 공을 쥐고 터치하면서 입력하는 방식입니다.

119
00:08:37,000 --> 00:08:42,000
OpenGL의 홈페이지는 opengl.org 입니다.

120
00:08:42,000 --> 00:08:47,000
OpenGL은 그래픽과 이미지를 다루는 많은 function들을 제공하고 있습니다.

121
00:08:47,000 --> 00:08:53,000
OpenGL은 API, 즉 Application Programming Interface가 아니라

122
00:08:53,000 --> 00:08:57,000
API의 specification, 즉, 사양 입니다.

123
00:08:57,000 --> 00:09:02,000
그러니까 OpenGL에는 어떤 기능의 함수와 변수들이 존재한다는

124
00:09:02,000 --> 00:09:04,000
표준이 기술되어 있습니다.

125
00:09:04,000 --> 00:09:10,000
즉, OpenGL은 C++, Java, Python, JavaScript 등

126
00:09:10,000 --> 00:09:14,000
다양한 프로그래밍 언어들로 구현될 수 있습니다.

127
00:09:14,000 --> 00:09:20,000
GLFW는 OpenGL과 함께 쓰이며, 그림이 그려질 window를 만들고

128
00:09:20,000 --> 00:09:25,000
장치들로 부터의 input, output을 담당하는 라이브러리 입니다.

129
00:09:25,000 --> 00:09:31,000
GLEW는 graphic card 제조사가 구현한 OpenGL 함수들을 찾아,

130
00:09:31,000 --> 00:09:36,000
우리의 OpenGL 프로그램과 연결시키는 역할을 해 주는 라이브러리 입니다.

131
00:09:36,000 --> 00:09:44,000
이번 코스에는 OpenGL과 함께 GLFW와 GLEW 의 조합을 사용할 것입니다.

132
00:09:44,000 --> 00:09:48,000
이제 우리의 첫번째 프로그램을 살펴볼 것입니다.

133
00:09:48,000 --> 00:09:54,000
00_HelloWindow는 윈도우를 하나 띄우는 간단한 프로그램입니다.

134
00:09:54,000 --> 00:10:00,000
다른 윈도우와 마찬가지로 마우스로 윈도우를 resize할 수 있습니다.

135
00:10:00,000 --> 00:10:03,000
프로그램을 끝내는 방법은 두가지가 있는데

136
00:10:03,000 --> 00:10:07,000
ESC key를 누르거나 종료 버튼을 누르는 것입니다.

137
00:10:07,000 --> 00:10:14,000
프로그램의 첫 부분에는 glew.h 와 glfw3.h 라는

138
00:10:14,000 --> 00:10:18,000
두 개의 header file을 include 해 주어야 합니다.

139
00:10:18,000 --> 00:10:24,000
그 아래에는 이후에 define될 두 function들의 prototype입니다.

140
00:10:24,000 --> 00:10:26,000
framebuffer_size_callback은

141
00:10:26,000 --> 00:10:30,000
window가 resize되었을 때 call되는 callback function 입니다.

142
00:10:30,000 --> 00:10:33,000
processInput 은 rendering loop에서

143
00:10:33,000 --> 00:10:37,000
input이 들어와 있는지를 check하는 function 입니다.

144
00:10:37,000 --> 00:10:40,000
SCR_WIDTH와 SCR_HEIGHT는

145
00:10:40,000 --> 00:10:45,000
생성될 윈도우의 크기를 나타내는 global variable입니다.

146
00:10:45,000 --> 00:10:50,000
우리는 800 x 600 크기의 윈도우를 만들 것입니다.

147
00:10:50,000 --> 00:10:55,000
main 함수의 첫 부분에서 먼저 GLFW를 initialize 하고,

148
00:10:55,000 --> 00:10:58,000
OpenGL version을 3.3 으로 정합니다.

149
00:10:58,000 --> 00:11:01,000
그리고 이 부분은 window를 생성하는 부분입니다.

150
00:11:01,000 --> 00:11:06,000
여기에서 current context를 방금 생성한 window로 setting 합니다.

151
00:11:06,000 --> 00:11:12,000
이렇게 하면 다음 에 나오는 명령들은 모두 이 window에 대해 작용하게 됩니다.

152
00:11:12,000 --> 00:11:17,000
그리고 FramebufferSizeCallback 함수로 framebuffer_size_callback이

153
00:11:17,000 --> 00:11:20,000
register되는 것을 볼 수 있습니다

154
00:11:20,000 --> 00:11:26,000
나머지 부분은 glew 를 initialize하는 것을 보여주고 있습니다.

155
00:11:26,000 --> 00:11:30,000
이 부분은 실제로 윈도우에 무언가를 그려내고

156
00:11:30,000 --> 00:11:35,000
input에 맞춰 어떤 프로세싱을 하는 main loop 부분입니다.

157
00:11:35,000 --> 00:11:40,000
이러한 종류의 프로그램은 흔히 종료 이벤트가 들어오기 전까지

158
00:11:40,000 --> 00:11:42,000
loop를 반복하게 되는데,

159
00:11:42,000 --> 00:11:48,000
loop 안에서 input 즉 event를 체크하고 update된 무엇인가를 그리게 됩니다.

160
00:11:48,000 --> 00:11:52,000
흔히 게임 프로그램에서도 이러한 loop를 볼 수 있습니다.

161
00:11:52,000 --> 00:11:57,000
이런 loop를 event loop 또는 main loop 등의 이름으로 부릅니다.

162
00:11:57,000 --> 00:12:02,000
우리의 경우 glfwWindowShouldClose 함수로

163
00:12:02,000 --> 00:12:05,000
quit event가 들어왔는지를 체크하고

164
00:12:05,000 --> 00:12:11,000
종료 버튼이나 ESC key 가 발생한 경우  loop를 빠져나가도록 되어 있습니다.

165
00:12:11,000 --> 00:12:16,000
loop 안에서 처음 하는 일은 어떤 input이 들어왔는지를 살펴보는 것입니다.

166
00:12:16,000 --> 00:12:21,000
흔히 mouse, keyboard 등의 input이 들어온 경우 처리를 하게 됩니다.

167
00:12:21,000 --> 00:12:26,000
glClearColor는 윈도우의 배경 컬러를 지정하는 일을 합니다.

168
00:12:26,000 --> 00:12:29,000
RGBA 포맷으로 지정되는데

169
00:12:29,000 --> 00:12:36,000
여기서는 (0.2, 0.3, 0.3, 1.0) 의 값으로 지정하였습니다.

170
00:12:36,000 --> 00:12:41,000
여기서 Alpha 값 1.0 은 완전 불투명한 Opaque 컬러임을 나타냅니다.

171
00:12:41,000 --> 00:12:45,000
glClear()함수는 특정한 buffer를 clear하는데,

172
00:12:45,000 --> 00:12:50,000
GL_COLOR_BUFFER_BIT 는 우리가 그리는 것들이 저장되는 buffer

173
00:12:50,000 --> 00:12:54,000
즉 frame buffer 내의 color buffer 를 말하는 것이며,

174
00:12:54,000 --> 00:12:59,000
clear 명령을 내리면 여기에서 지정된 배경 색깔로 clear됩니다.

175
00:12:59,000 --> 00:13:04,000
우리의 00_HelloWindow 프로그램은 배경만을 보여주기 때문에

176
00:13:04,000 --> 00:13:07,000
clear한 후 더 그리는 것은 없습니다.

177
00:13:07,000 --> 00:13:11,000
다 그린 이후에는 buffer를 swap해 주는

178
00:13:11,000 --> 00:13:15,000
glfwSwapBuffers() 명령을 내립니다.

179
00:13:15,000 --> 00:13:20,000
이것은 front와 back buffer를 서로 exchange하는 역할을 하는데,

180
00:13:20,000 --> 00:13:24,000
자세한 것은 추후의 슬라이드에서 설명합니다.

181
00:13:24,000 --> 00:13:29,000
glfwPollEvents() 는 loop body의 마지막에 call 되는데

182
00:13:29,000 --> 00:13:33,000
다음 처리될 input이 들어오는지 감시하게 됩니다.

183
00:13:33,000 --> 00:13:37,000
종료 event가 들어와서 main loop에서 빠져나오면

184
00:13:37,000 --> 00:13:40,000
마무리를 하고 프로그램을 끝내게 됩니다.

185
00:13:40,000 --> 00:13:45,000
glfwTerminate() 는 윈도우를 kill하는 역할을 합니다.

186
00:13:45,000 --> 00:13:50,000
main 함수 외에 두 개의 함수가 더 있습니다.

187
00:13:50,000 --> 00:13:52,000
먼저 processInput 함수는

188
00:13:52,000 --> 00:13:56,000
어떤 input event가 발생했는지 check하는 역할을 합니다.

189
00:13:56,000 --> 00:14:00,000
이 예에서는 ESC 키가 들어왔는지를 check하고

190
00:14:00,000 --> 00:14:04,000
들어왔으면 WindowShouldClose를 true로 set하여

191
00:14:04,000 --> 00:14:07,000
main loop를 빠져나오도록 합니다.

192
00:14:07,000 --> 00:14:11,000
두 번쨰 함수는 framebuffer_size_callback 인데,

193
00:14:11,000 --> 00:14:17,000
이 함수는 아까 callback 함수로 register된 것을 기억하실 수 있을 겁니다.

194
00:14:17,000 --> 00:14:22,000
이 callback 함수는 window size가 변경되면 바로 실행이 됩니다.

195
00:14:22,000 --> 00:14:27,000
parameter로 들어오는 width와 height는 변경된 이후의 사이즈 들이며

196
00:14:27,000 --> 00:14:31,000
GLFW에서 return해 주는 것입니다.

197
00:14:31,000 --> 00:14:36,000
우리는 viewport 사이즈를 새 window 사이즈에 맞도록 변경해 주는데

198
00:14:36,000 --> 00:14:39,000
glViewport 함수를 사용합니다.

199
00:14:39,000 --> 00:14:43,000
그리고 새로운 width와 height 값을 나중에 쓸 수 있도록

200
00:14:43,000 --> 00:14:49,000
SCR_WIDTH와 SCR_HEIGHT라는 global variable로 저장해 놓습니다.

201
00:14:49,000 --> 00:14:53,000
보통 컴퓨터에는 디스플레이를 위한 두 개의 buffer가 있는데,

202
00:14:53,000 --> 00:14:56,000
front와 back buffer가 그것들입니다.

203
00:14:56,000 --> 00:15:01,000
디스플레이 화면에는 언제나 front buffer에 담겨있는 내용이 보여지게 됩니다.

204
00:15:01,000 --> 00:15:06,000
한편, 응용 프로그램은 front가 아닌 back buffer에 무엇인가를 그리게 됩니다.

205
00:15:06,000 --> 00:15:11,000
그림과 같이 애니메이션의 한 프레임이 화면에 보여지고 있는 상태에서

206
00:15:11,000 --> 00:15:15,000
프로그램은 다음 프레임을 back buffer에 그리는 것입니다.

207
00:15:15,000 --> 00:15:18,000
그 후에 front와 back buffer를 바꿔치기 합니다.

208
00:15:18,000 --> 00:15:22,000
다르게 말하면, front와 back buffer를 가리키고 있는

209
00:15:22,000 --> 00:15:25,000
pointer를 서로 바꿔주는 것입니다.

210
00:15:25,000 --> 00:15:30,000
이렇게 하면 새로운 프레임을 그리는 동안 나타날 수 있는

211
00:15:30,000 --> 00:15:33,000
깜빡거림 현상을 막아줄 수 있습니다.

212
00:15:33,000 --> 00:15:38,000
하나의 버퍼만을 사용했을 때 깜빡거림현상이 생깁니다.

213
00:15:38,000 --> 00:15:43,000
이 동영상을 보시면 single buffering을 사용할 때의 깜박거림을 볼 수 있습니다.

214
00:15:43,000 --> 00:15:47,000
Viewport는 화면에 실제로 그려지는 영역을 의미합니다.

215
00:15:47,000 --> 00:15:50,000
이미 정의된 drawing window내에서

216
00:15:50,000 --> 00:15:54,000
실제로 그림이 그려질 영역의 왼쪽-아래 코너 좌표와

217
00:15:54,000 --> 00:15:57,000
그 영역의 넓이, 높이를 정의합니다.

218
00:15:57,000 --> 00:16:03,000
만약 glViewPort(0, 0, width, height) 를 call 했을 경우

219
00:16:03,000 --> 00:16:06,000
그려질 영역은 window 전체가 됩니다.

220
00:16:06,000 --> 00:16:09,000
이것이 default viewport이기도 합니다.

221
00:16:09,000 --> 00:16:15,000
두 번째 예와 같이 하여 window의 1사분면에만 그림을 그릴 수도 있습니다.

222
00:16:15,000 --> 00:16:20,000
이런식으로 하면, 한 윈도우에 여러 개의 view를 동시에 그리는 것도 가능합니다.
