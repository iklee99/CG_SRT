1
00:00:00,000 --> 00:00:05,300
이 note에서는 view space를 clip space로 변환하는

2
00:00:05,300 --> 00:00:07,450
projection transformation과

3
00:00:07,450 --> 00:00:11,380
viewport transformation에 대해 알아봅니다.

4
00:00:11,380 --> 00:00:14,290
clipping 과정은 어떤 삼각형이

5
00:00:14,290 --> 00:00:19,010
clipping volume의 경계에 걸쳐 있는 경우,

6
00:00:19,010 --> 00:00:23,200
내부에 있는 부분과 외부에 있는 부분을 분리하여

7
00:00:23,200 --> 00:00:26,750
내부에 있는 쪽만 그리는 과정을 말합니다.

8
00:00:26,750 --> 00:00:30,180
왼쪽 그림에서는 삼각형들 중

9
00:00:30,180 --> 00:00:33,390
clipping volume의 안쪽에 있는 부분들만 보여지고,

10
00:00:33,390 --> 00:00:39,250
clipping out 된 나머지 부분들은 화면에 보이지 않게 됩니다.

11
00:00:39,250 --> 00:00:43,430
오른쪽 그림은 line segments (선분) 들이

12
00:00:43,430 --> 00:00:47,230
clipping volume에 대해 상대적으로 위치할 수 있는 경우들을

13
00:00:47,230 --> 00:00:49,340
나열한 것입니다.

14
00:00:49,340 --> 00:00:54,110
A는 완전히 clipping volume의 바깥쪽에 있는 경우,

15
00:00:54,110 --> 00:00:57,080
B는 완전히 안쪽에 있는 경우,

16
00:00:57,080 --> 00:01:02,540
C와 D는 부분적으로 안쪽에 있는 경우들을 말합니다.

17
00:01:02,540 --> 00:01:07,510
3차원에 정의된 물체를 2D 스크린에 그려 내어야 하기 때문에

18
00:01:07,510 --> 00:01:11,060
3D에서 2D로의 mapping이 필요하게 됩니다.

19
00:01:11,060 --> 00:01:14,270
이 과정을 projection이라 부릅니다.

20
00:01:14,270 --> 00:01:19,740
그림에서 보면 projector들과 view plane이 교차하는 점들로

21
00:01:19,740 --> 00:01:23,490
point들이 projection 되고 있음을 알 수 있습니다.

22
00:01:23,490 --> 00:01:28,940
여기에서, projector는, COP, 즉 camera의 position과

23
00:01:28,940 --> 00:01:33,290
object위의 점을 잇는 직선입니다.

24
00:01:33,290 --> 00:01:36,000
Projection에는 두가지 종류가 있는데,

25
00:01:36,000 --> 00:01:38,820
먼저 parallel projection은

26
00:01:38,820 --> 00:01:42,660
COP가 무한대로 멀리 있는 경우입니다.

27
00:01:42,660 --> 00:01:46,090
모든 projector들이 평행합니다.

28
00:01:46,090 --> 00:01:49,010
이 경우에는 Object의 크기 비율이

29
00:01:49,010 --> 00:01:52,420
그대로 유지되어 projection 됩니다.

30
00:01:52,420 --> 00:01:54,550
원근감이 없기 때문에

31
00:01:54,550 --> 00:01:58,430
우리가 사는 실세상과는 다릅니다.

32
00:01:58,430 --> 00:02:00,140
parallel projection은

33
00:02:00,140 --> 00:02:03,230
크기나 거리의 정확성이 요구되는

34
00:02:03,230 --> 00:02:06,410
기계설계 등에 쓰입니다.

35
00:02:06,410 --> 00:02:08,770
Perspective projection에서는

36
00:02:08,770 --> 00:02:12,100
COP가 유한한 거리에 존재합니다.

37
00:02:12,100 --> 00:02:15,680
좀 더 현실적인 projection 방법입니다.

38
00:02:15,680 --> 00:02:21,150
멀리 있는 물체는 작게, 가까이 있는 물체는 크게 projection 되므로,

39
00:02:21,150 --> 00:02:25,570
실제 크기의 비율이 유지되지는 않습니다.

40
00:02:25,570 --> 00:02:27,970
컴퓨터 그래픽스에서는 대부분

41
00:02:27,970 --> 00:02:32,000
perspective projection을 사용합니다.

42
00:02:32,000 --> 00:02:34,300
Parallel projection은 간단합니다.

43
00:02:34,300 --> 00:02:37,890
3D 좌표의 x 및 y 좌표를 유지하고

44
00:02:37,890 --> 00:02:40,630
z 좌표는 무시하면 됩니다.

45
00:02:40,630 --> 00:02:44,730
COP와 view plane간의 거리를 d라 합시다.

46
00:02:44,730 --> 00:02:48,740
Point Pc = (xc, yc, zc)가

47
00:02:48,740 --> 00:02:52,970
camera space에 존재한다고 가정합니다.

48
00:02:52,970 --> 00:02:56,560
Parallel projection matrix는 이렇게 간단합니다.

49
00:02:56,560 --> 00:03:02,780
x, y 좌표는 그대로이고, z좌표는 d가 됩니다.

50
00:03:02,780 --> 00:03:07,170
GLM이 제공하는 parallel projection matrix가 있습니다.

51
00:03:07,170 --> 00:03:11,010
glm::ortho 함수를 사용하는데,

52
00:03:11,010 --> 00:03:13,790
parameter들은 left와 right 범위,

53
00:03:13,790 --> 00:03:15,940
bottom과 top의 범위,

54
00:03:15,940 --> 00:03:20,170
near와 far의 범위를 각각 나타내고 있습니다.

55
00:03:20,170 --> 00:03:26,880
이 범위 안에 드는 것들만 clip되어 NDC로 변환되게 됩니다.

56
00:03:26,880 --> 00:03:30,020
이제 perspective projection을 고려하기 위해

57
00:03:30,020 --> 00:03:33,130
view volume을 정의하도록 하겠습니다.

58
00:03:33,130 --> 00:03:38,500
View volume은 viewing frustum 이라고도 불리는데요.

59
00:03:38,500 --> 00:03:41,910
이것은 truncated pyramid,

60
00:03:41,910 --> 00:03:44,670
즉, 머리가 잘린 피라미드를

61
00:03:44,670 --> 00:03:47,810
옆으로 뉘어 놓은 모양입니다.

62
00:03:47,810 --> 00:03:51,500
near와 far plane 사이에 존재하는 물체들만이

63
00:03:51,500 --> 00:03:54,830
view plane으로 projection 됩니다.

64
00:03:54,830 --> 00:03:58,860
흔히 view plane과 near clip plane을

65
00:03:58,860 --> 00:04:02,410
동일하게 놓는 경우가 많습니다.

66
00:04:02,410 --> 00:04:04,320
Camera가 바라보는 viewing direction이

67
00:04:04,320 --> 00:04:09,250
view plane, near plane, far plane과 수직을 이루며,

68
00:04:09,250 --> 00:04:17,440
viewing direction vector는 각 plane의 중심을 관통합니다.

69
00:04:17,440 --> 00:04:22,060
Pc = (xc, yc, zc)를 view space의

70
00:04:22,060 --> 00:04:26,370
view volume 상단 평면위의 한 점이라 가정합시다.

71
00:04:26,370 --> 00:04:30,020
Pc를 view plane 상에 projection하여,

72
00:04:30,020 --> 00:04:36,420
point Ps = (xs, ys, zs)를 얻는다고 가정합니다.

73
00:04:36,420 --> 00:04:43,500
여기서 zs는 COP로 부터 view plane까지의 거리 d와 같습니다.

74
00:04:43,500 --> 00:04:49,690
ys는 닮은꼴 삼각형의 비례식에 의해 구할 수 있습니다.

75
00:04:49,690 --> 00:04:55,500
즉, ys/d는 yc/dc와 같으므로,

76
00:04:55,500 --> 00:05:00,820
ys = d * (yc/zc) 입니다.

77
00:05:00,820 --> 00:05:05,600
비슷한 과정으로, xs의 값도 구할 수 있습니다.

78
00:05:05,600 --> 00:05:10,100
앞에서 구한 xs와 ys 좌표를 가지고,

79
00:05:10,100 --> 00:05:11,250
perspective transformation의

80
00:05:11,250 --> 00:05:16,330
4x4 matrix를 구해 보겠습니다.

81
00:05:16,330 --> 00:05:19,940
Matrix T_pers는 view coordinates를

82
00:05:19,940 --> 00:05:24,030
view plane위로 projection하는 matrix 입니다.

83
00:05:24,030 --> 00:05:26,800
T_pers matrix는 이렇게 생겼습니다.

84
00:05:26,800 --> 00:05:32,030
자세히 보면 맨 아래 row가 [0, 0, 0, 1] 이 아니라

85
00:05:32,030 --> 00:05:36,050
[0, 0, 1, 0] 인 것을 알 수 있습니다.

86
00:05:36,050 --> 00:05:42,570
이 때문에 transformation 결과의 w좌표는 1이 아니게 됩니다.

87
00:05:42,570 --> 00:05:45,800
이 homogenous coordinates의 w component로

88
00:05:45,800 --> 00:05:49,620
x, y, z component들을 나누면

89
00:05:49,620 --> 00:05:56,160
최종적으로 이와 같이 projection 된 결과를 얻을 수 있습니다.

90
00:05:56,160 --> 00:05:59,270
Projection에 그치지 않고,

91
00:05:59,270 --> 00:06:02,270
normalization transformation이라는 것을 하게 됩니다.

92
00:06:02,270 --> 00:06:05,360
이 때, 좌표는 projection space에서

93
00:06:05,360 --> 00:06:08,050
NDC로 변하게 됩니다.

94
00:06:08,050 --> 00:06:14,660
NDC에서는, projection으로 만들어진 2D의 (xs, ys) 좌표를

95
00:06:14,660 --> 00:06:22,140
x와 y가 각각 -1부터 1까지인 정사각형으로 transform합니다.

96
00:06:22,140 --> 00:06:27,140
뿐만아니라, zc의 좌표를 그냥 d로 고정하는 것이 아니라,

97
00:06:27,140 --> 00:06:29,540
원래 camera coordinates zc를

98
00:06:29,540 --> 00:06:37,040
d = -1, f = 1를 기준으로 scale해 줍니다.

99
00:06:37,040 --> 00:06:43,940
Large (X,Y)를 NDC의 (x,y) normalized coordinates라 하고,

100
00:06:43,940 --> 00:06:52,040
view plane window의 한변의 길이의 반을 h라 할 때,

101
00:06:52,040 --> 00:06:56,480
(X,Y)는 이와 같이 비례식으로 구할 수 있습니다.

102
00:06:56,480 --> 00:07:01,280
Canonical form의 z좌표는 zc를

103
00:07:01,280 --> 00:07:04,850
[-1,1] 구간으로 찌그려뜨려 넣는 것입니다.

104
00:07:04,850 --> 00:07:10,720
이 때, d = -1, f = 1 을 기준으로 합니다.

105
00:07:10,720 --> 00:07:15,810
Large Z를 canonical form의 z좌표라 합시다.

106
00:07:15,810 --> 00:07:19,500
Large Z는 이와 같은 식으로 구할 수 있습니다.

107
00:07:19,500 --> 00:07:24,080
확인을 위해 zc에 d와 f를 넣어 보면,

108
00:07:24,080 --> 00:07:28,310
large Z는 각각 0와 1이 됩니다.

109
00:07:28,310 --> 00:07:30,690
그렇다면 이 식을 어떻게

110
00:07:30,690 --> 00:07:35,420
4x4 matrix에 표현할 수 있을까요?

111
00:07:35,420 --> 00:07:38,960
이제 normalization을 포함하는 모든 과정을

112
00:07:38,960 --> 00:07:42,400
perspective transformation에 합쳐 봅니다.

113
00:07:42,400 --> 00:07:46,660
Canonical form 의 좌표는 homogeneous coordinates인

114
00:07:46,660 --> 00:07:50,300
[X, Y, Z, W] 로 나타낼 수 있습니다.

115
00:07:50,300 --> 00:07:57,540
그리고, perspective transform matrix는 이와 같습니다.

116
00:07:57,540 --> 00:08:03,450
GLM을 이용하여 perspective matrix도 쉽게 정의할 수 있습니다.

117
00:08:03,450 --> 00:08:06,910
glm::perspective 함수를 이용하는 것입니다.

118
00:08:06,910 --> 00:08:09,700
첫번째 parameter인 fov는

119
00:08:09,700 --> 00:08:11,950
field of view의 약자로써

120
00:08:11,950 --> 00:08:14,980
얼마나 넓은 범위를 view에 담을 수 있는지

121
00:08:14,980 --> 00:08:17,250
그 각도를 나타냅니다.

122
00:08:17,250 --> 00:08:20,040
fov는 그림에서와 같이

123
00:08:20,040 --> 00:08:24,100
y방향의 view volume 각도를 나타냅니다.

124
00:08:24,100 --> 00:08:30,380
aspect ratio는 width/height 의 비율을 나타냅니다.

125
00:08:30,380 --> 00:08:34,430
near와 far는 카메라로 부터

126
00:08:34,430 --> 00:08:39,490
near plane과 far plane까지의 거리를 나타냅니다.

127
00:08:39,490 --> 00:08:43,780
Canonical form이 유용한 것은 여러가지 이유가 있습니다만,

128
00:08:43,780 --> 00:08:47,680
가장 대표적인 것은 여기에서 보여드리는 것처럼 c

129
00:08:47,680 --> 00:08:49,700
anonical form을 이용하면

130
00:08:49,700 --> 00:08:53,820
clipping을 쉽게 할 수 있다는 점 일 것입니다.

131
00:08:53,820 --> 00:08:55,930
Normalized 되지 않은 경우의

132
00:08:55,930 --> 00:08:59,320
clipping test를 가정해 봅시다.

133
00:08:59,320 --> 00:09:04,160
point가 view frustum 안에 있는지를 test하기 위해

134
00:09:04,160 --> 00:09:08,100
view frustum의 경계를 이루는 평면들에 대해

135
00:09:08,100 --> 00:09:11,160
point의 in/out test를 해야 합니다.

136
00:09:11,160 --> 00:09:16,770
또 in/out에 걸쳐 있는 object의 in-part만을 구하기 위해

137
00:09:16,770 --> 00:09:21,930
평면과 object간의 intersection도 구해야 합니다.

138
00:09:21,930 --> 00:09:26,160
이 계산은 꽤 복잡하며 시간도 많이 걸립니다.

139
00:09:26,160 --> 00:09:30,170
반면에 canonical form을 사용하면 어떻습니까?

140
00:09:30,170 --> 00:09:32,530
point in/out test는

141
00:09:32,530 --> 00:09:38,420
x 또는 y좌표가 -1부터 1사이에 있는지 test하는 것이 되므로,

142
00:09:38,420 --> 00:09:40,540
매우 간단합니다.

143
00:09:40,540 --> 00:09:44,630
또한, Intersection 계산도 훨씬 간단해 집니다.

144
00:09:44,630 --> 00:09:50,040
이렇듯, canonical form을 사용하면 장점이 있습니다.

145
00:09:50,040 --> 00:09:56,080
Viewport는 screen에서 그림이 그려지게 되는 부분의 사각형을 말합니다.

146
00:09:56,080 --> 00:10:00,120
스크린 전체가 viewport가 되는 경우도 많이 있습니다.

147
00:10:00,120 --> 00:10:03,520
우리는 canonical form의 (x,y) 좌표를

148
00:10:03,520 --> 00:10:07,320
viewport window의 pixel 좌표로 변환해야 합니다.

149
00:10:07,320 --> 00:10:10,080
이전 slide에서 보았듯,

150
00:10:10,080 --> 00:10:12,610
canonical form의 (x,y) 좌표는

151
00:10:12,610 --> 00:10:18,010
각각 [-1,1] 의 범위에 있습니다.

152
00:10:18,010 --> 00:10:22,210
이것이 Canonical form (X,Y)에서

153
00:10:22,210 --> 00:10:26,620
viewport 좌표 (Vx, Vy)로 바꾸는 식입니다.

154
00:10:26,620 --> 00:10:34,750
Large (X,Y) 에 (-1,-1) 을 대입하면 (x1, y1) 이 나옵니다.

155
00:10:34,750 --> 00:10:38,850
(1, 1)을 대입하면 (x2, y2)가 나옵니다.

156
00:10:38,850 --> 00:10:42,690
식에 대한 자세한 설명은 생략하도록 하겠습니다.
