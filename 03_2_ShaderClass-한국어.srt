1
00:00:00,000 --> 00:00:03,780
이 강의에서는 Shader 사용을 간편하게 해 줄

2
00:00:03,780 --> 00:00:06,290
Shader class를 소개합니다.

3
00:00:06,290 --> 00:00:09,650
Shader source를 위한 GLSL 언어에서

4
00:00:09,650 --> 00:00:13,380
vector들에 관해 특이한 접근 방식들이 있습니다.

5
00:00:13,380 --> 00:00:15,970
component들의 이름을 xyzw 또는

6
00:00:15,970 --> 00:00:22,200
rgba 또는 stpq 로 할 수 있습니다.

7
00:00:22,200 --> 00:00:25,490
이러한 방식을 swizzling이라고 합니다.

8
00:00:25,490 --> 00:00:31,320
예를 들어 vec3 v3 를 (2,3,4)로 가정해 보겠습니다.

9
00:00:31,320 --> 00:00:36,170
이 중 x와 y components만 골라서 2D vector를 만들때,

10
00:00:36,170 --> 00:00:41,470
vec2 v2 에 v3.xy를 assign하면

11
00:00:41,470 --> 00:00:44,970
(2,3) 이라는 2D vector가 됩니다.

12
00:00:44,970 --> 00:00:52,820
유사하게, v4 를 v3.xxyz 로 assign하면

13
00:00:52,820 --> 00:00:57,230
(2,2,3,4) 라는 4D vector가 됩니다.

14
00:00:57,230 --> 00:01:03,680
마찬가지로, rgba, stpq 도 사용할 수 있는데

15
00:01:03,680 --> 00:01:07,390
rgba는 color의 component,

16
00:01:07,390 --> 00:01:14,180
stpq는 나중에 배울 texture coordinates를 나타낸다고 볼 수 있습니다.

17
00:01:14,180 --> 00:01:22,110
그러나 xyzw, rgba, stpq 간에 차이는 없고

18
00:01:22,110 --> 00:01:26,610
그냥 의미로만 차이가 있다고 볼 수 있습니다.

19
00:01:26,610 --> 00:01:30,690
주의할 점은 이들을 서로 섞어서 쓸 수는 없습니다.

20
00:01:30,690 --> 00:01:37,900
예를 들면, v3.xgbq 와 같이 하면 안 됩니다.

21
00:01:37,900 --> 00:01:39,770
Vector를 초기화 할 때도

22
00:01:39,770 --> 00:01:44,050
이렇게 일반적으로 constructor를 사용하는 방법이 있습니다.

23
00:01:44,050 --> 00:01:48,130
그리고 swizzling을 사용해서 초기화도 가능합니다.

24
00:01:48,130 --> 00:01:55,680
즉, v4.xyz와 마지막 field 2를 합쳐서

25
00:01:55,680 --> 00:02:00,550
새로운 4D vector를 정의할 수도 있습니다.

26
00:02:00,550 --> 00:02:03,870
vertex attribute는 각 vertex에 대해

27
00:02:03,870 --> 00:02:06,570
모두 다른 값을 가지게 됩니다.

28
00:02:06,570 --> 00:02:08,640
그러나 uniform variable은

29
00:02:08,640 --> 00:02:11,940
모든 vertex에 대해 같은 값을 가집니다.

30
00:02:11,940 --> 00:02:14,400
uniform variable에 값을 전달하려면

31
00:02:14,400 --> 00:02:16,470
두 단계를 거쳐야 합니다.

32
00:02:16,470 --> 00:02:23,590
먼저 glGetUniformLocation() 함수로 특정한 이름을 가지는

33
00:02:23,590 --> 00:02:27,530
uniform variable의 location을 알아냅니다.

34
00:02:27,530 --> 00:02:31,220
예제에서는 "outColor" 라는 이름의

35
00:02:31,220 --> 00:02:34,860
uniform variable의 location을 알아내고 있습니다.

36
00:02:34,860 --> 00:02:41,240
Location을 알아냈으면, glUniform4f() 를 이용,

37
00:02:41,240 --> 00:02:44,900
그 location으로 값을 전달합니다.

38
00:02:44,900 --> 00:02:50,290
여기서는 outColor가 rgba의 4D vector이기 때문에

39
00:02:50,290 --> 00:02:53,630
4개의 float 값을 전달하였습니다.

40
00:02:53,630 --> 00:02:56,480
우리의 예에서는 Fragment shader에서

41
00:02:56,480 --> 00:02:59,500
uniform ourColor 값을 받습니다.

42
00:02:59,500 --> 00:03:03,440
Attribute와 달리 uniform variable의 경우

43
00:03:03,440 --> 00:03:06,560
in/out을 따로 표시하지 않습니다.

44
00:03:06,560 --> 00:03:10,830
받아온 uniform variable을 FragColor로 assign하여

45
00:03:10,830 --> 00:03:13,890
pixel color로 결정하게 됩니다.

46
00:03:13,890 --> 00:03:18,130
이 과정을 그림으로 보면 application 프로그램에서

47
00:03:18,130 --> 00:03:21,690
vertex shader로 attribute들이 전달되고,

48
00:03:21,690 --> 00:03:25,940
fragment shader로 uniform color가 전달됩니다.

49
00:03:25,940 --> 00:03:28,420
vertex shader에서 계산된 gl_Position과

50
00:03:28,420 --> 00:03:33,330
fragment shader에서 계산된 FragColor가

51
00:03:33,330 --> 00:03:39,990
H/W로 전달되어 최종적으로 화면에 pixel이 나타나게 됩니다.

52
00:03:39,990 --> 00:03:41,950
그런데 uniform variable은

53
00:03:41,950 --> 00:03:45,530
항상 fragment shader로만 전달되는 것은 아닙니다.

54
00:03:45,530 --> 00:03:48,280
vertex shader에서도 필요한 경우

55
00:03:48,280 --> 00:03:51,860
uniform variable을 전달 받을 수 있습니다.

56
00:03:51,860 --> 00:03:54,130
그러나 attribute variable의 경우

57
00:03:54,130 --> 00:03:59,470
vertex shader로만 전달됩니다.

58
00:03:59,470 --> 00:04:02,680
07_ShaderClass 프로그램은 이제 까지와는 다른

59
00:04:02,680 --> 00:04:04,610
몇가지 특징들이 있습니다.

60
00:04:04,610 --> 00:04:08,440
삼각형의 내부에서 color interpolation이 되어

61
00:04:08,440 --> 00:04:12,250
세가지 color가 mix되는 것을 볼 수 있습니다.

62
00:04:12,250 --> 00:04:15,130
또한 timer를 이용하여 삼각형이 어두워졌다가

63
00:04:15,130 --> 00:04:18,110
밝아지는 것을 되풀이 하게 됩니다.

64
00:04:18,110 --> 00:04:24,640
또 shader 생성 및 사용과 관련한 복잡한 명령들을 쉽게 처리해 주는

65
00:04:24,640 --> 00:04:27,890
shader classs를 만들어 사용합니다.

66
00:04:27,890 --> 00:04:30,290
Shader class는 utils 폴더 안에

67
00:04:30,290 --> 00:04:34,250
"shader.h" 안에 define되어 있습니다.

68
00:04:34,250 --> 00:04:37,890
Class 전체가 header file안에 구현되어 있으므로

69
00:04:37,890 --> 00:04:42,010
header file만을 include 하면 됩니다.

70
00:04:42,010 --> 00:04:45,450
Shader class는 shader file source를 읽어와

71
00:04:45,450 --> 00:04:48,960
compile, linking, shader object를 만드는 과정을

72
00:04:48,960 --> 00:04:50,850
모두 포함하고 있습니다.

73
00:04:50,850 --> 00:04:55,850
또한 uniform variable을 shader로 쉽게 pass할 수 있도록

74
00:04:55,850 --> 00:04:58,320
함수들을 제공하고 있습니다.

75
00:04:58,320 --> 00:05:04,180
지금까지 해 오던 복잡한 shader setup 작업들을 간단히 하기 위해

76
00:05:04,180 --> 00:05:06,600
Shader class를 만들었습니다.

77
00:05:06,600 --> 00:05:09,670
Shader class는 생성된 shader program object의

78
00:05:09,670 --> 00:05:11,770
ID를 저장하고 있습니다.

79
00:05:11,770 --> 00:05:15,010
또, vertex와 fragment shader file 이름을

80
00:05:15,010 --> 00:05:19,980
parameter들로 넘기는 constructor를 가지고 있습니다.

81
00:05:19,980 --> 00:05:24,350
보통 이 constructor를 사용하여 shader를 초기화 합니다.

82
00:05:24,350 --> 00:05:29,820
Constructor를 부르지 않은 경우에는 initShader()를 이용하여

83
00:05:29,820 --> 00:05:34,280
vertex와 fragment shader file을 load할 수 있습니다.

84
00:05:34,280 --> 00:05:39,370
use() 함수는 glUseProgram() 을 call하여

85
00:05:39,370 --> 00:05:44,460
이후 렌더링에서 이 shader를 이용할 수 있도록 합니다.

86
00:05:44,460 --> 00:05:48,280
그 외에 uniform variable들을 pass할 수 있는

87
00:05:48,280 --> 00:05:51,180
utility function들이 있습니다

88
00:05:51,180 --> 00:05:53,630
Shader file들을 loading하면서

89
00:05:53,630 --> 00:05:56,640
shader object를 generate하는 데에

90
00:05:56,640 --> 00:05:59,180
constructor를 이용할 수 있습니다.

91
00:05:59,180 --> 00:06:03,310
이 constructor에서는 shader file을 읽어들여

92
00:06:03,310 --> 00:06:05,370
shader object들을 생성하고,

93
00:06:05,370 --> 00:06:08,240
shader program object를 생성하며,

94
00:06:08,240 --> 00:06:12,150
모든 initialization을 행하게 됩니다.

95
00:06:12,150 --> 00:06:14,170
같은 일을 하는 function으로

96
00:06:14,170 --> 00:06:19,030
initShader function을 사용할 수도 있습니다.

97
00:06:19,030 --> 00:06:23,370
Shader class를 이용할 때는 use() 함수를 call한 후

98
00:06:23,370 --> 00:06:30,320
적절한 VAO를 bind하고 draw하는 형태가 되겠습니다.

99
00:06:30,320 --> 00:06:33,870
Uniform variable을 shader로 pass할 때

100
00:06:33,870 --> 00:06:37,410
그 location을 찾고 값을 pass하는 것을

101
00:06:37,410 --> 00:06:40,860
간단히 하나의 function으로 해결할 수 있습니다.

102
00:06:40,860 --> 00:06:45,400
Variable의 type들에 따라 여러가지 함수들이 마련되어 있는데,

103
00:06:45,400 --> 00:06:51,480
setFloat, setBool, setInt, setVec2, setVec3,

104
00:06:51,480 --> 00:06:59,600
setVec4, setMat2, setMat3, setMat4 등이 있습니다.

105
00:06:59,600 --> 00:07:01,600
이 예제부터는 vertex shader와 fragment shader는

106
00:07:01,600 --> 00:07:02,600
각각 다른 file로 저장됩니다.

107
00:07:02,600 --> 00:07:04,100
여기서는 3.3.shader.vs 와

108
00:07:04,100 --> 00:07:06,100
3.3.shader.fs 로 저장되었습니다.

109
00:07:06,100 --> 00:07:08,600
vertex shader에는 position과 color attribute를 저장하는

110
00:07:08,600 --> 00:07:10,600
두 개의 attribute variable들이 정의되었습니다.

111
00:07:10,600 --> 00:07:12,100
uniform variable인 val은

112
00:07:12,100 --> 00:07:14,100
OpenGL application program으로부터 pass됩니다.

113
00:07:14,100 --> 00:07:16,100
ourColor는 4차원 RGBA color vector입니다.

114
00:07:16,100 --> 00:07:18,100
val 값이 ourColor의 각 component에 곱해진 후

115
00:07:18,100 --> 00:07:19,100
fragment shader로 전달됩니다.

116
00:07:19,100 --> 00:07:20,600
Fragment shader에서 ourColor는

117
00:07:20,600 --> 00:07:24,050
그대로 FragColor output variable로 assign됩니다.

118
00:07:24,050 --> 00:07:29,650
Vertex attribute data에 position 좌표에 바로 뒤 이어,

119
00:07:29,650 --> 00:07:30,200
각 vertex의 color들이

120
00:07:30,200 --> 00:07:34,600
RGB값으로 지정 되었습니다.

121
00:07:34,600 --> 00:07:38,030
아마 VBO에 고정된 format이 없다는 사실을

122
00:07:38,030 --> 00:07:42,060
여러분은 기억할 수 있을 것입니다.

123
00:07:42,060 --> 00:07:47,170
이렇게 VBO의 format은 그때그때 다를 수 있습니다.

124
00:07:47,170 --> 00:07:50,290
이제 하나의 VBO에 position과 color가

125
00:07:50,290 --> 00:07:52,890
번갈아 가며 저장되어 있습니다.

126
00:07:52,890 --> 00:07:57,820
즉, vertex1에 해당하는 position (x,y,z) 가 저장된 후

127
00:07:57,820 --> 00:08:03,780
vertex1의 color (r,g,b)가 저장되는 형식입니다.

128
00:08:03,780 --> 00:08:08,120
Position attribute들의 시작 offset=0 입니다.

129
00:08:08,120 --> 00:08:12,200
즉, VBO의 첫부분부터 시작합니다.

130
00:08:12,200 --> 00:08:16,490
그리고, 이어지는 position들 간의 간격, stride는 24 입니다.

131
00:08:16,490 --> 00:08:22,670
float 값이 4 bytes이고, position과 color, 각 3개씩,

132
00:08:22,670 --> 00:08:29,570
총 6개의 floats가 한 vertex 영역을 차지하고 있기 때문입니다.

133
00:08:29,570 --> 00:08:34,640
반면에 color attribute는 offset=12에서 시작합니다.

134
00:08:34,640 --> 00:08:38,490
맨 앞의 12 bytes는 vertex 1의 position이

135
00:08:38,490 --> 00:08:40,580
차지하고 있기 때문입니다.

136
00:08:40,580 --> 00:08:44,470
color들의 stride도 역시 24 입니다.

137
00:08:44,470 --> 00:08:49,500
Position attribute를 passing하기 위해

138
00:08:49,500 --> 00:08:56,820
glVertexAttribPointers()와 glEnableVertexAttrib를 사용하는데,

139
00:08:56,820 --> 00:09:01,320
여기에 지정되는 offset은 위에서 보았듯이 0입니다.

140
00:09:01,320 --> 00:09:08,630
Stride는 6 * sizeof(float) = 6 * 4 = 24 입니다.

141
00:09:08,630 --> 00:09:10,940
두번째로 color attribute는

142
00:09:10,940 --> 00:09:13,670
position attribute 이후에 시작하기 때문에

143
00:09:13,670 --> 00:09:17,590
offset은 3 * 4 = 12 입니다.

144
00:09:17,590 --> 00:09:24,570
Color attribute의 stride는 역시 24입니다.

145
00:09:24,570 --> 00:09:27,690
삼각형 내부의 pixel들의 color들은

146
00:09:27,690 --> 00:09:32,510
세개의 vertex color들의 interpolation으로 계산됩니다.

147
00:09:32,510 --> 00:09:36,830
이 interpolation은 rasterization stage에서 얻어진

148
00:09:36,830 --> 00:09:40,290
pixel position을 기반으로 계산됩니다.

149
00:09:40,290 --> 00:09:44,260
세 개 vertex들의 좌표를 각각

150
00:09:44,260 --> 00:09:49,200
(x1,y1), (x2,y2), (x3,y3) 이라 가정합니다.

151
00:09:49,200 --> 00:09:54,320
그리고, 세개 vertex들에 주어진 color를 각각

152
00:09:54,320 --> 00:09:59,200
c1, c2, c3라 가정 합니다.

153
00:09:59,200 --> 00:10:06,860
그림에서 pixel (x4,y4) 에서의 color c4 는 이와 같이 계산됩니다.

154
00:10:06,860 --> 00:10:16,370
즉, (x1,y1)과 (x2,y2)를 양 끝점으로 하는 선분 (line segment)에서

155
00:10:16,370 --> 00:10:21,250
(x4,y4)의 상대적인 위치에 따른 비례식입니다.

156
00:10:21,250 --> 00:10:29,220
마찬가지로 pixel (x5,y5)의 color c5는

157
00:10:29,220 --> 00:10:35,150
(x1,y1)과 (x3,y3)의 interpolation으로 계산됩니다.

158
00:10:35,150 --> 00:10:41,600
마지막으로 pixel (x6,y6)의 color는

159
00:10:41,600 --> 00:10:50,110
(x4,y4)와 (x5,y5)의 interpolation으로 계산할 수 있습니다.

160
00:10:50,110 --> 00:10:52,350
이제 삼각형의 color를 시간에 따라

161
00:10:52,350 --> 00:10:55,160
변화시키는 부분을 살펴 봅니다.

162
00:10:55,160 --> 00:10:59,570
우리는 시간 변화 t 에 관해 계산한 sin(t) 함수를 이용하여

163
00:10:59,570 --> 00:11:03,280
color를 정하려고 하기 때문에

164
00:11:03,280 --> 00:11:06,460
sin function이 정의되어 있는

165
00:11:06,460 --> 00:11:10,830
cmath header file을 include했습니다.

166
00:11:10,830 --> 00:11:16,370
GLFW에서 제공하는 현재 시간을 받아오는

167
00:11:16,370 --> 00:11:19,020
glfwGetTime을 사용합니다.

168
00:11:19,020 --> 00:11:23,630
이 함수는 프로그램이 시작된 이후로 지나간 시간을

169
00:11:23,630 --> 00:11:29,180
초단위의 float 값인 timeValue로 받아오게 됩니다.

170
00:11:29,180 --> 00:11:34,680
sin(timeValue) 값의 범위는 -1 에서 1 사이 입니다.

171
00:11:34,680 --> 00:11:41,180
이것을 [0,1] 범위로 바꾸기 위해 timeValue 값을 반으로 나누고

172
00:11:41,180 --> 00:11:44,510
여기에 0.5를 더합니다.

173
00:11:44,510 --> 00:11:48,460
이제 계산된 color를 uniform variable로

174
00:11:48,460 --> 00:11:53,260
vertex shader로 전달하면 됩니다.
