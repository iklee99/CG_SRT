1
00:00:03,000 --> 00:00:06,120
우리는 지금까지 NDC, 즉,

2
00:00:06,120 --> 00:00:10,580
normalized device coordinates를 사용하여 왔습니다.

3
00:00:10,580 --> 00:00:16,340
NDC에서는 x,y,z 방향의 각 coordinates 의 범위가

4
00:00:16,340 --> 00:00:19,820
-1에서 1사이로 제한됩니다.

5
00:00:19,820 --> 00:00:22,480
이 범위에 들지 않은 object는

6
00:00:22,480 --> 00:00:24,810
보이지 않게 되는 것이죠.

7
00:00:24,810 --> 00:00:29,590
그러나 이러한 제한은 너무 비현실적입니다.

8
00:00:29,590 --> 00:00:32,730
지금부터 우리는 우리가 사용할 space를

9
00:00:32,730 --> 00:00:35,970
임의로 자유롭게 정하게 될 것입니다.

10
00:00:35,970 --> 00:00:40,890
그리고 vertex shader에서는 이러한 임의의 space를

11
00:00:40,890 --> 00:00:43,860
NDC로 transform한 후

12
00:00:43,860 --> 00:00:50,360
그 결과인 gl_position을 hardware로 보내게 됩니다.

13
00:00:50,360 --> 00:00:55,440
그림에서 보면 연두색 직사각형과 노랑색 사분원이

14
00:00:55,440 --> 00:01:00,810
크기가 90x90 인 user-defined space의

15
00:01:00,810 --> 00:01:05,690
camera boundary에 그려진 것을 볼 수 있습니다.

16
00:01:05,690 --> 00:01:12,490
Vertex shader가 이것을 [-1,1] 사이의 NDC로 변환한 후,

17
00:01:12,490 --> 00:01:15,090
HW 로 보냅니다.

18
00:01:15,090 --> 00:01:21,040
Vertex coordinates는 여러 단계를 거치며 변환되게 됩니다.

19
00:01:21,040 --> 00:01:23,500
Local space에서 정의된 좌표는

20
00:01:23,500 --> 00:01:27,930
model transformation을 적용하여 world space로 변환되고,

21
00:01:27,930 --> 00:01:33,020
view transformation을 적용하여 view space로 변환됩니다.

22
00:01:33,020 --> 00:01:39,180
또한, projection transformation을 통해 clip space로 변환된 뒤,

23
00:01:39,180 --> 00:01:42,910
최종적으로 viewport transformation을 이용하여

24
00:01:42,910 --> 00:01:49,140
screen space로 변환되어 screen에 보여지게 됩니다.

25
00:01:49,140 --> 00:01:53,330
Local space는 object space라고도 불리는데,

26
00:01:53,330 --> 00:01:58,190
특정한 하나의 object에만 국한된 좌표계 입니다.

27
00:01:58,190 --> 00:02:02,700
예를 들어, Blender와 같은 graphics software에서

28
00:02:02,700 --> 00:02:06,650
cube 하나를 모델링한다고 가정해 봅시다.

29
00:02:06,650 --> 00:02:10,960
보통 처음에 cube는 원점을 중심으로 하고,

30
00:02:10,960 --> 00:02:15,740
edge의 하나의 길이가 1인 기본적인 모양을 가집니다.

31
00:02:15,740 --> 00:02:19,480
이후에 우리가 이것의 크기를 바꾸거나

32
00:02:19,480 --> 00:02:23,670
위치를 옮겨서 재배치 하거나 합니다.

33
00:02:23,670 --> 00:02:28,600
이렇게 object가 처음에 자신을 정의하기 위해 사용하는 좌표계를

34
00:02:28,600 --> 00:02:31,640
local space 라고 하고,

35
00:02:31,640 --> 00:02:37,840
이 때 vertex의 coordinates를 local coordinates라고 합니다.

36
00:02:37,840 --> 00:02:40,400
local space에서 정의된 object들은

37
00:02:40,400 --> 00:02:45,990
하나의 공간에 모여서 한 장면(scene)을 이루게 됩니다.

38
00:02:45,990 --> 00:02:51,050
예를 들면 한 장면 안에 집, 나무, 자동차 등이

39
00:02:51,050 --> 00:02:54,010
모두 출현하는 경우 입니다.

40
00:02:54,010 --> 00:02:57,700
집과 나무와 자동차는 모두 처음에

41
00:02:57,700 --> 00:03:02,830
자신만의 local space들에서 모델링 되었을 것입니다.

42
00:03:02,830 --> 00:03:08,040
이 때, 예를 들면, 각 오브젝트의 중심은 원점이고

43
00:03:08,040 --> 00:03:12,860
크기는 상대적으로 조절되어 있지 않을 것입니다.

44
00:03:12,860 --> 00:03:17,300
이 오브젝트들을 하나의 공간에 모아서 배치해야 하는데,

45
00:03:17,300 --> 00:03:22,630
이 하나의 공간을 world space라고 합니다.

46
00:03:22,630 --> 00:03:24,220
World coordinates는

47
00:03:24,220 --> 00:03:28,650
이 world space안에서 정의되는 좌표를 말합니다.

48
00:03:28,650 --> 00:03:33,590
그림에서 보면 로봇의 팔을 이루는 두개의 직사각형들은

49
00:03:33,590 --> 00:03:39,700
처음에 각각의 local space에서 A와 B로 모델링 되었습니다.

50
00:03:39,700 --> 00:03:43,150
이들을 하나의 world space로 옮겨서 배치하려면

51
00:03:43,150 --> 00:03:48,660
Local에서 world space로의 transformation이 필요하게 됩니다.

52
00:03:48,660 --> 00:03:53,570
Local에서 world로의 transformation을 나타내는 matrix를

53
00:03:53,570 --> 00:03:56,080
model matrix라고 부르고,

54
00:03:56,080 --> 00:04:01,390
이 transformation을 model transformation이라 부릅니다.

55
00:04:01,390 --> 00:04:05,550
그림에서는 cube가 local space로 부터

56
00:04:05,550 --> 00:04:07,990
model transformation에 따라

57
00:04:07,990 --> 00:04:12,630
world space로 옮겨지는 것을 볼 수 있습니다.

58
00:04:12,630 --> 00:04:16,560
World space의 object는 view transformation에 의해

59
00:04:16,560 --> 00:04:18,920
view space로 변환됩니다.

60
00:04:18,920 --> 00:04:24,170
View space는 camera space 또는 eye space라고도 불립니다.

61
00:04:24,170 --> 00:04:29,180
View space는 user의 view를 중심으로 정의되는 공간입니다.

62
00:04:29,180 --> 00:04:34,810
그림에서 보면 world space에 object들이 존재하고 있을 때,

63
00:04:34,810 --> 00:04:38,540
view space는 camera의 위치인 center of projection,

64
00:04:38,540 --> 00:04:44,080
즉, COP를 원점으로 가지는 공간입니다.

65
00:04:44,080 --> 00:04:47,730
View matrix로 나타내지는 view transformation은

66
00:04:47,730 --> 00:04:53,010
world에서 view space로 coordinates를 변환합니다

67
00:04:53,010 --> 00:04:58,420
다음은 view space에서 clip space로의 변환 입니다.

68
00:04:58,420 --> 00:05:01,860
Clip space는 clip coordinates로 정의되는데,

69
00:05:01,860 --> 00:05:05,110
이 clip coordinates가 바로 NDC 입니다.

70
00:05:05,110 --> 00:05:08,800
몇 번 이야기 했듯이 vertex shader에서

71
00:05:08,800 --> 00:05:11,480
최종적인 output gl_Position은

72
00:05:11,480 --> 00:05:15,000
NDC coordinates를 가져야 합니다.

73
00:05:15,000 --> 00:05:18,950
NDC는 x,y,z의 모든 coordinates들이

74
00:05:18,950 --> 00:05:23,290
[-1, 1] 의 범위에 있습니다.

75
00:05:23,290 --> 00:05:26,800
이 범위 안에 들지 않는 모든 coordinates들은

76
00:05:26,800 --> 00:05:29,040
화면에 보이지 않게 됩니다.

77
00:05:29,040 --> 00:05:38,170
예를 들면 (-2,0,0), (0.2,0.5,-5) 와 같은 점 들이죠.

78
00:05:38,170 --> 00:05:41,660
View space에서 clip space로의 변환은

79
00:05:41,660 --> 00:05:45,480
projection matrix에 의해 행해집니다.

80
00:05:45,480 --> 00:05:50,510
특히 projection transformation은 두 step들로 분리될 수 있는데,

81
00:05:50,510 --> 00:05:56,000
projection과 perspective division이 그것들입니다.

82
00:05:56,000 --> 00:06:00,110
마지막 남은 단계는 clip space의 coordinates를

83
00:06:00,110 --> 00:06:02,150
viewport transformation하여

84
00:06:02,150 --> 00:06:05,620
screen space coordinates로 바꾸는 것입니다.

85
00:06:05,620 --> 00:06:10,560
Screen space는 실제 display 화면에 나타나는 pixel 좌표 입니다.

86
00:06:10,560 --> 00:06:12,710
사실 이 viewport transformation은

87
00:06:12,710 --> 00:06:17,120
graphics H/W 에 의해 자동으로 일어나게 되어서

88
00:06:17,120 --> 00:06:20,730
우리가 프로그래밍 할 일은 없습니다.

89
00:06:20,730 --> 00:06:23,540
Model Transformation 프로그램에서는

90
00:06:23,540 --> 00:06:27,140
local coordinates를 가지는 basic cube를

91
00:06:27,140 --> 00:06:30,670
model transformation하여 world space로 옮기고,

92
00:06:30,670 --> 00:06:34,610
적절한 view, projection transformation을 거쳐

93
00:06:34,610 --> 00:06:40,120
NDC coordinates로 변환하는 과정을 보여줍니다.

94
00:06:40,120 --> 00:06:43,940
Vertex shader에는 Cube class의 data들이 전달되는

95
00:06:43,940 --> 00:06:48,820
position, normal, color, texture coordinates의 vector들이

96
00:06:48,820 --> 00:06:52,170
attribute variable들로 정의되어 있습니다.

97
00:06:52,170 --> 00:06:58,730
물론 normal과 texture coordinates들은 아직 사용되지 않습니다.

98
00:06:58,730 --> 00:07:01,290
toColor는 vertex shader로부터

99
00:07:01,290 --> 00:07:05,300
fragment shader로 전달될 out variable인데

100
00:07:05,300 --> 00:07:10,310
application program으로 부터 vertex shader로 전달됩니다.

101
00:07:10,310 --> 00:07:14,660
gl_Position은 model, view, projection matrix를

102
00:07:14,660 --> 00:07:20,730
순서대로 original position에 곱해서 계산됩니다.

103
00:07:20,730 --> 00:07:25,230
render() 함수에서 model, view, projection matrix를 만들고

104
00:07:25,230 --> 00:07:27,460
이들을 vertex shader에 전달하여

105
00:07:27,460 --> 00:07:30,210
transformation을 하게 하려고 합니다.

106
00:07:30,210 --> 00:07:33,400
먼저 model, view, projection 이라는

107
00:07:33,400 --> 00:07:39,150
세개의 4x4 matrix들을 identity로 초기화 합니다.

108
00:07:39,150 --> 00:07:42,970
cube의 animation을 위해 현재 시간을 알아내고,

109
00:07:42,970 --> 00:07:46,330
사용할 shader 등을 setting합니다.

110
00:07:46,330 --> 00:07:50,020
model transformation은 처음에

111
00:07:50,020 --> 00:07:54,230
현재 시간에 rotSpeed를 곱한 만큼의 각도로

112
00:07:54,230 --> 00:07:58,050
z축을 중심으로 cube를 회전시킵니다.

113
00:07:58,050 --> 00:08:01,120
오른쪽 맨 위 그림의 초기 위치,

114
00:08:01,120 --> 00:08:06,400
그 아래의 것이 z축으로 회전한 상태를 보여 줍니다.

115
00:08:06,400 --> 00:08:12,600
그리고 나서 x축에 관하여 -55도 만큼 cube를 회전합니다.

116
00:08:12,600 --> 00:08:18,080
이렇게 하면 일단 cube를 위한 model transformation이 되었고,

117
00:08:18,080 --> 00:08:22,480
시간이 지남에 따라 애니메이션이 가능해 집니다.

118
00:08:22,480 --> 00:08:27,290
View transformation으로는 camera를 적절히 위치 시켜야 하는데,

119
00:08:27,290 --> 00:08:31,040
여기서는 glm::lookAt 함수를 사용하였습니다.

120
00:08:31,040 --> 00:08:36,230
Camera를 (0, 0, 3) 에 위치시키고, camera가 바라보고 있는 점,

121
00:08:36,230 --> 00:08:39,930
즉 target point를 원점으로 하였습니다.

122
00:08:39,930 --> 00:08:45,590
Camera의 up vector를 (0, 1, 0), 즉, Y 축으로 하였습니다.

123
00:08:45,590 --> 00:08:48,360
이 lookAt 함수가 어떻게 구현되는지는

124
00:08:48,360 --> 00:08:52,510
다음 slide에서 자세히 설명하도록 하겠습니다.

125
00:08:52,510 --> 00:08:55,860
참고로 OpenGL의 default camera는

126
00:08:55,860 --> 00:09:01,030
원점에 위치하면서 –Z 방향을 바라보고 있습니다.

127
00:09:01,030 --> 00:09:03,580
다음으로 projection matrix는

128
00:09:03,580 --> 00:09:07,450
glm::perspective라는 편리한 함수가 있습니다.

129
00:09:07,450 --> 00:09:14,370
이 함수의 parameter로는 FOV (field of view), aspect ratio,

130
00:09:14,370 --> 00:09:17,410
near, far 가 주어지는데,

131
00:09:17,410 --> 00:09:22,040
이 의미들과 함께 Projection transformation의 구현에 대해서도

132
00:09:22,040 --> 00:09:25,770
추후 하나의 slide를 할애합니다.

133
00:09:25,770 --> 00:09:29,370
이제 model, view, projection matrix들을

134
00:09:29,370 --> 00:09:33,280
shader로 uniform variable형태로 전달하고,

135
00:09:33,280 --> 00:09:35,180
cube를 그립니다.
