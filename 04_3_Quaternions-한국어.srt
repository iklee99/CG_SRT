1
00:00:00,000 --> 00:00:03,200
Quaternion에 대한 강의 시작하겠습니다.

2
00:00:03,200 --> 00:00:05,840
3D 에서 rotation을 계산하는데

3
00:00:05,840 --> 00:00:08,620
효율적이고 안정적인 방법 중의 하나는

4
00:00:08,620 --> 00:00:11,480
quaternion을 이용하는 것입니다.

5
00:00:11,480 --> 00:00:16,610
Quaternion은 4차원의 vector (q0, q1, q2, q3)로서,

6
00:00:16,610 --> 00:00:18,440
하나의 scalar q0와

7
00:00:18,440 --> 00:00:23,490
하나의 3D vector q = (q1, q2, q3)로

8
00:00:23,490 --> 00:00:26,500
이루어져 있다고 볼 수 있습니다.

9
00:00:26,500 --> 00:00:30,720
Quaternion의 이론은 상당히 복잡한 것들이 많이 있습니다만

10
00:00:30,720 --> 00:00:34,120
우리 코스에서는 rotation의 계산에 사용할

11
00:00:34,120 --> 00:00:38,270
최소한의 것들만 소개하도록 하겠습니다.

12
00:00:38,270 --> 00:00:41,010
먼저 두 개의 quaternion

13
00:00:41,010 --> 00:00:47,130
a = (q0,q)와 b = (p0 p)가 주어졌습니다.

14
00:00:47,130 --> 00:00:52,700
두 quaternion의 합 a + b는 정상적인 4D vector들의 합인데,

15
00:00:52,700 --> 00:00:55,640
대응하는 element들을 더하여 계산합니다.

16
00:00:55,640 --> 00:00:59,340
두 quaternion의 곱 ab는

17
00:00:59,340 --> 00:01:02,750
여기에 주어진 식과 같이 계산됩니다.

18
00:01:02,750 --> 00:01:08,800
여기에는 a와 b가 포함하는 3D vector들 q와 p의

19
00:01:08,800 --> 00:01:13,730
dot product와 cross product가 사용되었습니다.

20
00:01:13,730 --> 00:01:16,830
Quaternion의 크기 (magnitude, size)는

21
00:01:16,830 --> 00:01:21,020
정상적인 4D vector의 크기입니다.

22
00:01:21,020 --> 00:01:26,150
Quaternion의 곱셈에 대한 inverse a^(-1) 는

23
00:01:26,150 --> 00:01:27,840
이 식과 같이 정의 됩니다.

24
00:01:27,840 --> 00:01:34,690
a와 a^(-1)의 곱은 곱셈에 대한 항등원 (1, 0)이 됩니다.

25
00:01:34,690 --> 00:01:37,560
Quternion을 사용하여 3D point를

26
00:01:37,560 --> 00:01:40,710
임의의 축에 대해 rotate할 수 있습니다.

27
00:01:40,710 --> 00:01:45,750
먼저 rotation을 할 3D point u = (x,y,z) 로

28
00:01:45,750 --> 00:01:51,170
quaternio p = (0, u) 를 만듭니다.

29
00:01:51,170 --> 00:01:56,060
Rotation axis가 unit vector v 로 주어집니다.

30
00:01:56,060 --> 00:02:00,420
이제 v축에 관해 u를 theta만큼 rotate한 결과인

31
00:02:00,420 --> 00:02:08,580
u’ 을 구하는 방법, 즉, u’ = 𝑅_𝑣(𝜃)𝑢 을 보겠습니다..

32
00:02:08,580 --> 00:02:11,930
먼저 unit quaternion r을 만듭니다:

33
00:02:11,930 --> 00:02:16,350
그리고 r의 inverse 를 다음과 같이 정의합니다:

34
00:02:16,350 --> 00:02:20,130
r의 inverse도 unit quaternion 입니다.

35
00:02:20,130 --> 00:02:25,800
그러면 p’ = (0, u’)은 다음 식에 의해 구해집니다:

36
00:02:25,800 --> 00:02:30,980
p’ = r p r^(-1)

37
00:02:30,980 --> 00:02:33,700
Quaternion과 rotation matrix form 간에는

38
00:02:33,700 --> 00:02:36,660
서로 conversion이 가능합니다.

39
00:02:36,660 --> 00:02:41,180
Rotation을 나타내는 quaternion r이 이렇게 주어졌다고 할 때,

40
00:02:41,180 --> 00:02:45,920
여기에 해당하는 rotation matrix는 다음과 같이 주어집니다.

41
00:02:45,920 --> 00:02:50,230
RotAxis 프로그램에서는 3D cube를 만들고,

42
00:02:50,230 --> 00:02:54,870
이를 임의의 축에 대해 회전시키고 있습니다.

43
00:02:54,870 --> 00:02:57,240
Keyboard q를 누르면 quaternion을 이용하여

44
00:02:57,240 --> 00:02:59,380
rotation을 계산하게 되고,

45
00:02:59,380 --> 00:03:03,520
m을 누르면 matrix를 이용하여 계산하게 됩니다.

46
00:03:03,520 --> 00:03:07,300
실제로 이 두 방법 사이에 차이가 없기 때문에

47
00:03:07,300 --> 00:03:13,090
방식이 바뀔 때 rotation이 끊어지거나 하지는 않습니다.

48
00:03:13,090 --> 00:03:17,940
GLM에서 quaternion에 대한 함수들을 지원하고 있습니다.

49
00:03:17,940 --> 00:03:23,970
이들을 이용하기 위해 위와 같은 header file을 include합니다.

50
00:03:23,970 --> 00:03:29,500
이 프로그램에서는 처음으로 3D의 object인 cube를 그리게 됩니다.

51
00:03:29,500 --> 00:03:33,720
앞으로도 cube를 계속 여러번 사용하게 될 것이기 때문에,

52
00:03:33,720 --> 00:03:40,480
cube를 만들고 그리는 데 사용할 Cube class를 정의해 놓았습니다.

53
00:03:40,480 --> 00:03:44,780
utils folder 안의 cube.h에 들어 있으며,

54
00:03:44,780 --> 00:03:49,310
header 안에 모든 구현이 다 포함되어 있습니다.

55
00:03:49,310 --> 00:03:52,540
Cube class에는 cube object를 위한

56
00:03:52,540 --> 00:03:57,830
vertex들의 좌표 등의 데이터가 이미 정의되어 있습니다.

57
00:03:57,830 --> 00:04:03,910
Cube vertex position은 6개 face에 각각 4개 vertex들에 대한

58
00:04:03,910 --> 00:04:06,400
x,y,z의 세개씩의 좌표가 있기 때문에

59
00:04:06,400 --> 00:04:12,250
모두 72 (6 x 4 x 3) 개의 element가

60
00:04:12,250 --> 00:04:15,120
cubeVertices array에 존재합니다.

61
00:04:15,120 --> 00:04:18,430
Default 좌표들로 원점을 중심으로 하며

62
00:04:18,430 --> 00:04:24,010
모든 edge의 길이가 1인 정육면체의 좌표들을 나타내고 있습니다.

63
00:04:24,010 --> 00:04:27,170
그 외에 normal 과 texture coordinates는

64
00:04:27,170 --> 00:04:32,050
앞으로 배울 rendering 방식들에서 사용하게 될 데이터 입니다.

65
00:04:32,050 --> 00:04:36,300
그 외에 face들의 color도 정의되어 있습니다.

66
00:04:36,300 --> 00:04:39,180
cubeIndices에는 DrawElements에 사용할

67
00:04:39,180 --> 00:04:42,920
index들이 정의되어 있습니다.

68
00:04:42,920 --> 00:04:45,270
Cube 클래스 안에는 cube를 그리기 위한

69
00:04:45,270 --> 00:04:49,840
VAO, VBO, EBO들이 정의되어 있습니다.

70
00:04:49,840 --> 00:04:52,030
Default constructor가 존재해서

71
00:04:52,030 --> 00:04:57,170
필요한 모든 buffer들을 만들고 초기화 할 수 있습니다.

72
00:04:57,170 --> 00:04:59,610
두 번째 constructor로는

73
00:04:59,610 --> 00:05:02,730
default vertex position들을 변경하여

74
00:05:02,730 --> 00:05:06,180
coordinates들을 바꿀 수 있습니다.

75
00:05:06,180 --> 00:05:08,900
초기에 위치하는 cube의 center position을

76
00:05:08,900 --> 00:05:11,790
(dx, dy, dz)로 바꿀 수 있으며,

77
00:05:11,790 --> 00:05:14,960
uniform scale factor s를 적용하여

78
00:05:14,960 --> 00:05:18,210
초기 크기를 바꿀 수 있습니다.

79
00:05:18,210 --> 00:05:25,220
draw() 함수는 주어진 shader를 사용하여 cube를 그리는 함수입니다.

80
00:05:25,220 --> 00:05:28,910
프로그램에서는 먼저 global 변수들을 정의하고 있는데,

81
00:05:28,910 --> 00:05:33,890
axis는 cube를 회전시킬 회전축을 정의하고 있습니다.

82
00:05:33,890 --> 00:05:37,210
여기서는 (1, 1, 1)로 주어져 있네요.

83
00:05:37,210 --> 00:05:42,540
또, 초기의 cube의 위치 (여기에서는 (0.4, 0.4, 0)) 와

84
00:05:42,540 --> 00:05:47,010
초기 크기 (여기서는 0.3)을 정의하였습니다.

85
00:05:47,010 --> 00:05:51,010
main() 에서 cube를 constructor로 만들어 냅니다.

86
00:05:51,010 --> 00:05:56,460
회전축은 미리 unit vector로 normalize하여 놓습니다.

87
00:05:56,460 --> 00:05:59,560
render함수에서는 먼저 identity 로 초기화된

88
00:05:59,560 --> 00:06:03,870
transformation matrix를 준비합니다.

89
00:06:03,870 --> 00:06:10,510
keyboard input에 의해 변화되는 rotState가 MAT_ROT 인 경우에는

90
00:06:10,510 --> 00:06:15,710
glm::rotate를 사용하여 transform matrix를 만들어 냅니다.

91
00:06:15,710 --> 00:06:21,690
rotState가 QUAT_ROT인 경우에는 quaternion을 이용하는데,

92
00:06:21,690 --> 00:06:27,170
GLM 함수인 glm::angleAxis는 주어진 axis와 angle을 가지고

93
00:06:27,170 --> 00:06:30,990
rotation에 해당하는 quaternion을 만들어 냅니다.

94
00:06:30,990 --> 00:06:34,980
이를 glm::toMat4 함수를 이용하여

95
00:06:34,980 --> 00:06:37,640
rotation matrix로 conversion 하고,

96
00:06:37,640 --> 00:06:41,520
이것을 transform matrix로 사용하면 됩니다.

97
00:06:41,520 --> 00:06:47,130
남은 부분에서는 shader에 transform matrix를 전달하고,

98
00:06:47,130 --> 00:06:50,850
cube->draw()를 call하여 cube를 그리게 됩니다.

99
00:06:50,850 --> 00:06:54,530
Vertex shader에는 cube class의 data들이 전달되는

100
00:06:54,530 --> 00:06:56,210
position, normal, color, texture coordinates의

101
00:06:56,210 --> 00:06:59,280
vector들이 정의되어 있습니다.

102
00:06:59,280 --> 00:07:03,860
물론 normal과 texture coordinates들은 아직 사용되지 않습니다.

103
00:07:03,860 --> 00:07:06,450
그러나, Cube class에서 이 data들을

104
00:07:06,450 --> 00:07:11,200
항상 VBO로 copy하도록 구현되어 있기 때문에

105
00:07:11,200 --> 00:07:13,740
이 4개의 attribute들을

106
00:07:13,740 --> 00:07:16,050
vertex shader에서 받아 주어야 합니다.

107
00:07:16,050 --> 00:07:21,870
Fragment shader로 전달될 toColor out variable입니다.

108
00:07:21,870 --> 00:07:27,810
transform matrix가 uniform variable로 전달됩니다.

109
00:07:27,810 --> 00:07:31,430
gl_Position은 transform matrix를

110
00:07:31,430 --> 00:07:36,700
original position에 곱해서 계산됩니다.
