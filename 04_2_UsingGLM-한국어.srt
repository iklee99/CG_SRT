1
00:00:00,000 --> 00:00:04,220
UsingGLM 강의 시작하겠습니다.

2
00:00:04,220 --> 00:00:06,520
OpenGL에서 vector와 matrix연산을

3
00:00:06,520 --> 00:00:08,200
쉽게 하기 위해 쓰이는

4
00:00:08,200 --> 00:00:11,930
유용한 library가 GLM입니다.

5
00:00:11,930 --> 00:00:14,620
사실 vector나 matrix class들을

6
00:00:14,620 --> 00:00:18,300
programmer가 직접 만들어서 사용할 수도 있습니다만,

7
00:00:18,300 --> 00:00:21,210
GLM은 검증된 library이기 때문에

8
00:00:21,210 --> 00:00:23,840
이것을 사용하겠습니다.

9
00:00:23,840 --> 00:00:26,000
GLM은 OpenGL 뿐만 아니라

10
00:00:26,000 --> 00:00:28,060
linear system을 필요로 하는

11
00:00:28,060 --> 00:00:30,100
많은 application들을 구현하는데

12
00:00:30,100 --> 00:00:33,060
널리 쓰이고 있습니다.

13
00:00:33,060 --> 00:00:36,800
GLM은 header file에 모든 구현이 되어 있기 때문에,

14
00:00:36,800 --> 00:00:40,450
필요한 header file들만을 include하면 되고,

15
00:00:40,450 --> 00:00:43,020
linking이나 compiling 같은 과정은

16
00:00:43,020 --> 00:00:44,860
따로 필요하지 않습니다.

17
00:00:44,860 --> 00:00:48,670
우리는 이미 GLM을 인스톨하여 놓았습니다.

18
00:00:48,670 --> 00:00:54,580
그래서 이예와 비슷하게 header file들을 include 하면 됩니다.

19
00:00:54,580 --> 00:00:59,000
GLM을 사용하는 예를 간단히 들어 보도록 하겠습니다.

20
00:00:59,000 --> 00:01:02,680
glm::vec4 는 4D vector type으로,

21
00:01:02,680 --> 00:01:06,660
이렇게 initialize할 수 있습니다.

22
00:01:06,660 --> 00:01:10,300
glm::mat4 는 4x4 matrix type 인데,

23
00:01:10,300 --> 00:01:13,640
우리가 사용하려는 transformation matrix들을

24
00:01:13,640 --> 00:01:17,820
나타내는 데 이용할 수 있습니다.

25
00:01:17,820 --> 00:01:21,760
Initialize할 때 1.0이라는 값을 하나만 넣어주면

26
00:01:21,760 --> 00:01:25,820
identity matrix로 initialize됩니다.

27
00:01:25,820 --> 00:01:28,810
1 외에 다른 값을 하나만 넣어주는 경우,

28
00:01:28,810 --> 00:01:34,590
그 값을 대각선 원소들에 배치하는 matrix가 됩니다.

29
00:01:34,590 --> 00:01:37,920
Composite transformation을 위해

30
00:01:37,920 --> 00:01:40,000
matrix들을 곱해나가기 위해서

31
00:01:40,000 --> 00:01:46,520
trans 라는 matrix를 처음에 identity matrix로 초기화 합니다.

32
00:01:46,520 --> 00:01:50,720
glm::translate 함수는 뒤의 parameter인

33
00:01:50,720 --> 00:01:55,040
vec3(1, 1, 0) 만큼 translation하는

34
00:01:55,040 --> 00:02:00,060
translation matrix로 만들어 이를 return 합니다.

35
00:02:00,060 --> 00:02:04,930
이제 trans는 translation matrix가 되었습니다.

36
00:02:04,930 --> 00:02:10,050
실제로 어떤 vector (또는 point) 의 좌표를 translation하려면

37
00:02:10,050 --> 00:02:13,140
trans와 vector를 곱하면 됩니다.

38
00:02:13,140 --> 00:02:20,020
여기서는 (1, 0, 0)을 (1, 1, 0)만큼 translation했으니,

39
00:02:20,020 --> 00:02:23,440
(2, 1, 0)이 나오게 됩니다.

40
00:02:23,440 --> 00:02:28,410
이번에는 scaling과 rotation을 적용하는 경우입니다.

41
00:02:28,410 --> 00:02:34,120
먼저 앞서의 예와 마찬가지로 identity matrix I를 준비합니다.

42
00:02:34,120 --> 00:02:38,910
다음에는 I에 90도 회전하는 rotation matrix를 곱해서

43
00:02:38,910 --> 00:02:41,930
IR matrix를 구합니다.

44
00:02:41,930 --> 00:02:46,740
rotate 함수의 맨 끝 parameter는 회전축인 z축입니다.

45
00:02:46,740 --> 00:02:53,440
IR에 scale matrix 를 곱해 IRS matrix를 계산합니다.

46
00:02:53,440 --> 00:03:00,190
IRS 와 vector v를 곱해 v를 scale하고 회전시킵니다.

47
00:03:00,190 --> 00:03:08,590
Transformation의 적용 순서는 scale을 먼저하고 그리고 나서 회전합니다.

48
00:03:08,590 --> 00:03:11,710
이번에는  application program으로 부터

49
00:03:11,710 --> 00:03:15,590
shader로 전달된 transformation matrix를 사용하여

50
00:03:15,590 --> 00:03:21,110
vertex의 position을 변화시켜 보도록 하겠습니다.

51
00:03:21,110 --> 00:03:23,620
uniform mat4 transform 이라는

52
00:03:23,620 --> 00:03:28,260
4x4  matrix가 shader로 전달되었습니다.

53
00:03:28,260 --> 00:03:32,780
transform matrix와 aPos vector를 곱해

54
00:03:32,780 --> 00:03:40,030
최종적인 vertex position gl_Position을 계산하게 됩니다.

55
00:03:40,030 --> 00:03:44,670
앞의 slide들에서는 application program 내에서

56
00:03:44,670 --> 00:03:48,030
transform된 vertex의 position을 계산했습니다.

57
00:03:48,030 --> 00:03:52,800
그러나, 더 많이 사용되는 방식은, 이 예에서와 같이

58
00:03:52,800 --> 00:03:57,550
matrix와 original vertex position을 따로 전달하고

59
00:03:57,550 --> 00:04:01,310
shader에서 이 둘을 곱하는 방법입니다.

60
00:04:01,310 --> 00:04:04,680
이렇게 하면 original vertex position은

61
00:04:04,680 --> 00:04:07,210
GPU로 한번만 전달해 놓고,

62
00:04:07,210 --> 00:04:11,730
transformation이 바뀔 때마다 matrix만 다시 전달해서

63
00:04:11,730 --> 00:04:17,260
변환된 position으로 update하는 것이 가능해 집니다.

64
00:04:17,260 --> 00:04:20,200
이 코드는 application program에서

65
00:04:20,200 --> 00:04:22,440
shader로 transformation matrix를

66
00:04:22,440 --> 00:04:25,600
전달하는 과정을 보여주고 있습니다.

67
00:04:25,600 --> 00:04:28,330
먼저 "transform" 이라는 이름을 가지는

68
00:04:28,330 --> 00:04:32,260
shader의 uniform 변수의 location을 찾습니다.

69
00:04:32,260 --> 00:04:36,770
이 과정에 glGetUniformLocation 함수가 이용됩니다.

70
00:04:36,770 --> 00:04:45,660
그러고 나서 glUniformMatrix4fv를 이용하여 matrix를 전달합니다.

71
00:04:45,660 --> 00:04:51,300
transformLoc은 좀 전에 찾은 location입니다.

72
00:04:51,300 --> 00:04:55,000
1은 전달할 matrix의 갯수 입니다.

73
00:04:55,000 --> 00:04:58,650
그 다음 것은 transpose option 입니다.

74
00:04:58,650 --> 00:05:04,370
Matrix를 transpose하는 경우에는 GL_TRUE를 씁니다.

75
00:05:04,370 --> 00:05:07,840
여기서 우리는 transpose할 필요가 없으므로

76
00:05:07,840 --> 00:05:12,220
그냥 GL_FALSE를 사용합니다.

77
00:05:12,220 --> 00:05:17,820
마지막 parameter는 전달할 matrix 변수 입니다.

78
00:05:17,820 --> 00:05:23,980
GLM format에서 GLSL format으로 conversion하기 위해

79
00:05:23,980 --> 00:05:30,260
matrix trans를 glm::value_ptr로 감싸서 전달했습니다.

80
00:05:30,260 --> 00:05:33,950
이번 program에서는 box하나를 만든 이후에,

81
00:05:33,950 --> 00:05:39,170
그 것을 scale하고, rotate하고, translate하는 변환들을

82
00:05:39,170 --> 00:05:43,360
composite transformation으로 적용해 봅니다.

83
00:05:43,360 --> 00:05:45,700
Render function에서 필요한

84
00:05:45,700 --> 00:05:50,250
transformation matrix들을 곱해 주고 있습니다.

85
00:05:50,250 --> 00:05:53,520
먼저 identity matrix를 만들고,

86
00:05:53,520 --> 00:05:59,670
거기에 translate, rotate, scale matrix들을 차례로 곱해줍니다.

87
00:05:59,670 --> 00:06:03,860
여러번 언급 했듯이, matrix를 곱하는 순서는

88
00:06:03,860 --> 00:06:08,420
transformation이 적용되는 순서와 반대입니다.

89
00:06:08,420 --> 00:06:12,770
matrix가 계산되면, 이것을 shader로 전달합니다.

90
00:06:12,770 --> 00:06:17,760
그 이후에 VAO를 렌더링 하면 됩니다.

91
00:06:17,760 --> 00:06:20,020
몇가지 실험을 해 보도록 합시다.

92
00:06:20,020 --> 00:06:23,370
이 예에서는 transformation matrix를

93
00:06:23,370 --> 00:06:26,730
처음에 identity로 초기화 한 그대로

94
00:06:26,730 --> 00:06:30,560
다른 어떤 transformation도 추가하지 않았습니다.

95
00:06:30,560 --> 00:06:33,650
이 경우에는 scale, rotation, translation 의

96
00:06:33,650 --> 00:06:36,950
어떤 것들도 적용되지 않았기 때문에

97
00:06:36,950 --> 00:06:41,600
box는 앞의 프로그램보다 크고, 회전하지 않으며,

98
00:06:41,600 --> 00:06:46,430
중심이 화면 가운데 위치하게 됩니다.

99
00:06:46,430 --> 00:06:50,000
이 경우는 scale만 적용된 경우입니다.

100
00:06:50,000 --> 00:06:54,830
rotation과 translation은 이루어지지 않았습니다.

101
00:06:54,830 --> 00:07:00,350
이 경우는 rotation과 scale이 적용된 경우입니다.

102
00:07:00,350 --> 00:07:03,230
Translation이 적용되지 않았기 때문에,

103
00:07:03,230 --> 00:07:06,200
회전하는 box는 화면의 중심에 있습니다.

104
00:07:06,200 --> 00:07:13,960
이 경우는 scale, rotation, translation이 모두 적용된 경우 입니다.

105
00:07:13,960 --> 00:07:17,130
이 예에서는 scale을 먼저 한 후,

106
00:07:17,130 --> 00:07:23,450
rotation과 translation을 적용하는 순서를 바꾸어 본 경우 입니다.

107
00:07:23,450 --> 00:07:27,220
translation을 먼저 한 후 rotate를 하면

108
00:07:27,220 --> 00:07:31,730
box는 translation된 위치에서 큰 원을 그리며

109
00:07:31,730 --> 00:07:34,780
원점을 중심으로 회전하게 됩니다.

110
00:07:34,780 --> 00:07:39,320
그러나 rotation을 먼저 적용한 후 translation을 하면,

111
00:07:39,320 --> 00:07:45,190
원점에 있는 box의 중심을 기준으로 box가 자체적으로 먼저 회전하면서

112
00:07:45,190 --> 00:07:49,070
이를 translation한 효과가 나게 됩니다.

113
00:07:49,070 --> 00:07:54,460
video들을 보고 그 차이점을 확인하도록 하십시오.

114
00:07:54,460 --> 00:07:59,540
이 프로그램에서는 두 개의 사각형이 서로 다른 scale을 가지고 있고,

115
00:07:59,540 --> 00:08:04,280
회전도 서로 다른 speed로 하고 있습니다.

116
00:08:04,280 --> 00:08:09,290
Global variable로 speed1과 speed2를 정의 하였습니다.

117
00:08:09,290 --> 00:08:15,200
speed1은 초당 90도를, speed2는 초당 45도를 회전하는

118
00:08:15,200 --> 00:08:18,460
speed를 나타내고 있습니다.

119
00:08:18,460 --> 00:08:23,600
Rendering 부분에서 먼저 왼쪽 위의 빨강색 사각형을 그리는 부분입니다.

120
00:08:23,600 --> 00:08:28,920
Scale, rotate, translation의 matrix를 곱해서

121
00:08:28,920 --> 00:08:32,670
composite transformation matrix를 만듧니다.

122
00:08:32,670 --> 00:08:37,800
우리는 rotation angle 계산에 speed1을 사용하였습니다.

123
00:08:37,800 --> 00:08:43,230
또 scale은 x, y, z축 방향 모두 0.5로 setting되었습니다.

124
00:08:43,230 --> 00:08:48,270
그리고, 계산된 transformation matrix와 color (빨강색)을

125
00:08:48,270 --> 00:08:51,850
uniform variable들로 shader로 전달하였습니다.

126
00:08:51,850 --> 00:08:56,920
Shader object에서 제공하는 set 함수를 사용하면 간단합니다.

127
00:08:56,920 --> 00:09:01,120
그런 뒤에 VAO를 그리면 됩니다.

128
00:09:01,120 --> 00:09:03,970
두 번째 사각형을 그리는 부분입니다.

129
00:09:03,970 --> 00:09:07,580
두번째 사각형은 non-uniform scaling이 적용되어,

130
00:09:07,580 --> 00:09:14,970
x, y, z방향으로 각각 0.3, 0.5, 1.0배로 scale되었습니다.

131
00:09:14,970 --> 00:09:18,520
노랑색 color가  shader로 전달 되었습니다
